{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Start here \u26a0 Important deprecation note Current circom is a compiler written in Rust. The old circom compiler written in Javascript will be frozen, but it can still be downloaded from the old circom repository . About the circom ecosystem The circom compiler and its ecosystem of tools allows you to create, test and create zero knowledge proofs for your circuits. circom circom is a compiler written in Rust for compiling circuits written in the circom language. The compiler outputs the representation of the circuit as constraints and everything needed to compute different ZK proofs. circomlib With circom , it is possible to create large circuits by combining smaller generic circuits called templates . The circomlib is a library of circom templates that contains hundreds of circuits such as comparators, hash functions, digital signatures, binary and decimal convertors and many more. You can also create your custom templates, but before start coding, we recommend you to take a look at our already created templates. The package already contains tests for circuits available in the circomlib . The package also installs the npm packages circomlibjs , circom_tester and ffjavascript as dependencies. circomlibjs circomlibjs is a Javascript library that provides programs to compute the witness of several circuits of circomlib . This library is used to check that the witness computed using the wasm or c code generated by circom form many circuits in the circomlib match the ones generated by the corresponding Javascript program in circomlibjs . The package includes these programs in the src directory. In the test directory it includes its own tests. In the tools directory it includes programs to precompute some needed parameters. circom_tester The circomtester is a npm package that provides tools for testing circom circuits. ffjavascript The ffjavascript is a npm package with Javascript code to perform finite field operations in Javascript. snarkjs snarkjs is a npm package that contains code to generate and validate ZK proofs from the artifacts produced by circom . Visual summary","title":"Home"},{"location":"#start-here","text":"","title":"Start here"},{"location":"#important-deprecation-note","text":"Current circom is a compiler written in Rust. The old circom compiler written in Javascript will be frozen, but it can still be downloaded from the old circom repository .","title":"&#9888; Important deprecation note"},{"location":"#about-the-circom-ecosystem","text":"The circom compiler and its ecosystem of tools allows you to create, test and create zero knowledge proofs for your circuits.","title":"About the circom ecosystem"},{"location":"#circom","text":"circom is a compiler written in Rust for compiling circuits written in the circom language. The compiler outputs the representation of the circuit as constraints and everything needed to compute different ZK proofs.","title":"circom"},{"location":"#circomlib","text":"With circom , it is possible to create large circuits by combining smaller generic circuits called templates . The circomlib is a library of circom templates that contains hundreds of circuits such as comparators, hash functions, digital signatures, binary and decimal convertors and many more. You can also create your custom templates, but before start coding, we recommend you to take a look at our already created templates. The package already contains tests for circuits available in the circomlib . The package also installs the npm packages circomlibjs , circom_tester and ffjavascript as dependencies.","title":"circomlib"},{"location":"#circomlibjs","text":"circomlibjs is a Javascript library that provides programs to compute the witness of several circuits of circomlib . This library is used to check that the witness computed using the wasm or c code generated by circom form many circuits in the circomlib match the ones generated by the corresponding Javascript program in circomlibjs . The package includes these programs in the src directory. In the test directory it includes its own tests. In the tools directory it includes programs to precompute some needed parameters.","title":"circomlibjs"},{"location":"#circom_tester","text":"The circomtester is a npm package that provides tools for testing circom circuits.","title":"circom_tester"},{"location":"#ffjavascript","text":"The ffjavascript is a npm package with Javascript code to perform finite field operations in Javascript.","title":"ffjavascript"},{"location":"#snarkjs","text":"snarkjs is a npm package that contains code to generate and validate ZK proofs from the artifacts produced by circom .","title":"snarkjs"},{"location":"#visual-summary","text":"","title":"Visual summary "},{"location":"background/background/","text":"Background Zero-knowledge proofs Recently, a set of cryptographic primitives called zero-knowledge proofs \\(ZKPs\\) agitated the world of public blockchains and distributed ledgers. ZKPs came up first as a solution to privacy issues but they have lately also stood up as a perfect solution to scalability issues. As a result, these cryptographic proofs have become very attractive tools to the blockchain community, and the most efficient algorithms have already been deployed and integrated in several applications. A zero-knowledge proof is a protocol that enables one party, called the prover , to convince another, the verifier , that a statement is true without revealing any information beyond the veracity of the statement. For example, a prover can create proofs for statements like the following: \"I know the private key that corresponds to this public key\" : in this case, the proof would not reveal any information about the private key. \"I know a private key that corresponds to a public key from this list\" : as before, the proof would not reveal information about the private key but in this case, the associated public key would also remain private. \"I know the preimage of this hash value\" : in this case, the proof would show that the prover knows the preimage but it would not reveal any information about the value of that preimage. \"This is the hash of a blockchain block that does not produce negative balances\" : in this case, the proof would not reveal any information about the amount, origin or destination of the transactions included in the block. Non-interactive zero-knowledge proofs \\(NIZK\\) are a particular type of zero-knowledge proofs in which the prover can generate the proof without interaction with the verifier. NIZK protocols are very suitable for Ethereum blockchain applications, because they allow a smart contract to act as a verifier . This way, anyone can generate a proof and send it as part of a transaction to the smart contract, which can perform some action depending on whether the proof is valid or not. In this context, the most preferable NIZK are zk-SNARK proofs \\(Zero-knowledge Succinct Non Interactive ARgument of Knowledge\\) , a set of non-interactive zero-knowledge protocols that have succinct proof size and sublinear verification time . The importance of these protocols is double: on the one hand, they help improve privacy guarantees, but on the other, their small proof size has been used in scalability solutions. Arithmetic circuits Like most ZKPs, zk-SNARKs permits proving computational statements , but they cannot be applied to the computational problem directly, the statement first needs to be converted into the right form. Specifically, zk-SNARKs requires the computational statement to be modeled with an arithmetic circuit. Although it may not always be obvious how to do this conversion, most computational problems we care about can easily be converted into arithmetic circuits. An F_p -arithmetic circuit is a circuit consisting of set of wires that carry values from the field F_p and connect them to addition and multiplication gates modulo p . \ud83d\udc49 Remember that given a prime number p , the finite field F_p consists of the set of numbers {0,...,p-1} on which we can add and multiply these numbers modulo p . For example, the finite field F_7 consists of the set of numbers {0,...,6} on which we can add and multiply numbers modulo 7 . An easy way to understand how operating modulo 7 works, is to think of a clock of 7 hours in which we do not care about how many times the hands have turned the clock, only what time they mark. In other words, we only care about the reminder of dividing by 7. For instance: 15 modulo 7 = 1 , since 15 = 7 + 7 + 1 7 modulo 7 = 0 4*3 modulo 7 = 5 , since 4*3 = 12 = 7 + 5 Signals of a circuit So, an arithmetic circuit takes some input signals that are values between 0,...,p-1 and performs additions and multiplications between them modulo the prime p . The output of every addition and multiplication gate is considered an intermediate signal , except for the last gate of the circuit, the output of which , is the output signal of the circuit. To generate and validate zk-SNARK proofs in Ethereum , we need to work with F_p -arithmetic circuits, taking the prime: p = 21888242871839275222246405745257275088548364400416034343698204186575808495617 In the figure below, we have defined an F_7 -arithmetic circuit that performs the operation: out = a*b + c . The circuit has 5 signals: the signals a , b and c are input signals, d is an intermediate signal and the out signal is the output of the circuit. \u200b In order to use zk-SNARK protocols, we need to describe the relation between signals as a system of equations that relate variables with gates. From now on, the equations that describe the circuit will be called constraints , and you can think of them as conditions that signals of that circuit must satisfy. Rank-1 constraint system If we have an arithmetic circuit with signals s_1,...,s_n , then we define a constraint as an equation of the following form: (a_1*s_1 + ... + a_n*s_n) * (b_1*s_1 + ... + b_n*s_n) + (c_1*s_1 + ... + c_n*s_n) = 0 Note that constraint must be quadratic, linear or constant equations , and sometimes, by doing small modifications \\(like a change of variable or gathering two constraints\\) , it is possible to reduce the number of constraints or variables. In general, circuits will have several constraints \\(typically, one per multiplicative gate\\) . The set of constraints describing the circuit is called rank-1 constraint system \\(R1CS\\) : (a_11*s_1 + ... + a_1n*s_n)*(b_11*s_1 + ... + b_1n*s_n) + (c_11*s_1 + ... + c_1n*s_n) = 0 (a_21*s_1 + ... + a_2n*s_n)*(b_21*s_1 + ... + b_2n*s_n) + (c_21*s_1 + ... + c_1n*s_n) = 0 (a_31*s_1 + ... + a_3n*s_n)*(b_31*s_1 + ... + b_3n*s_n) + (c_31*s_1 + ... + c_1n*s_n) = 0 ... ... (a_m1*s_1 + ... + a_mn*s_n)*(b_m1*s_1 + ... + b_mn*s_n) + (c_m1*s_1 + ... + c_mn*s_n) = 0 Remember that operations inside the circuit are performed modulo a certain prime p . So, all equations above are defined modulo p . In the previous example, the R1CS of our circuit consists of the following two equations: d = a*b modulo 7 out = d+c modulo 7 In this case, by replacing directly the variable d , we can gather the two equations into a single one: out = a*b + c modulo 7 The nice thing about circuits, is that although most zero-knowledge protocols have an inherent complexity that can be overwhelming for many developers, the design of arithmetic circuits is clear and neat . \ud83d\udc49 With circom , you design your own circuits with your own constraints, and the compiler outputs the R1CS representation that you will need for your zero-knowledge proof. Zero-knowledge permits proving circuit satisfiability . What this means is, that you can prove that you know a set of signals that satisfy the circuit, or in other words, that you know a solution to the R1CS. This set of signals is called witness . Witness Given a set of inputs, the calculation of the intermediate and output signals is pretty straightforward. So, given any set of inputs, we can always calculate the rest of signals. So, why should we talk about circuit satisfiability? The key aspect of zero-knowledge proofs, is that it allows you to compute these circuits without revealing information about the signals. For instance, imagine that in the previous circuit, the input a is a private key and the input b is the corresponding public key. You may be okay with revealing b but you certainly do not want to reveal a . If we define a as a private input, b , c as public inputs and out as a public output, with zero-knowledge we are able to prove, without revealing its value, that we know a private input a such that, for certain public values b , c and out , the equation a*b + c = out mod 7 holds. Note that we could easily deduce the value of a by isolating it from the other signals. It is important to design circuits that keep the privacy of the private inputs and prevent deducing them from the R1CS. An assignment of the signals is called a witness . For example, {a = 2, b = 6, c = -1, out = 4} would be a valid witness for the circuit. The assignment {a = 1, b = 2, c = 1, out = 0} would not be a valid witness, since it does not satisfy the equation a*b - c = out . Summary \u200b In summary, zk-SNARK proofs are an specific type of zero-knowledge proofs that allow you to prove that you know a set of signals \\(witness\\) that match all the constraints of a circuit without revealing any of the signals except the public inputs and the outputs.","title":"Background in ZK"},{"location":"background/background/#background","text":"","title":"Background"},{"location":"background/background/#zero-knowledge-proofs","text":"Recently, a set of cryptographic primitives called zero-knowledge proofs \\(ZKPs\\) agitated the world of public blockchains and distributed ledgers. ZKPs came up first as a solution to privacy issues but they have lately also stood up as a perfect solution to scalability issues. As a result, these cryptographic proofs have become very attractive tools to the blockchain community, and the most efficient algorithms have already been deployed and integrated in several applications. A zero-knowledge proof is a protocol that enables one party, called the prover , to convince another, the verifier , that a statement is true without revealing any information beyond the veracity of the statement. For example, a prover can create proofs for statements like the following: \"I know the private key that corresponds to this public key\" : in this case, the proof would not reveal any information about the private key. \"I know a private key that corresponds to a public key from this list\" : as before, the proof would not reveal information about the private key but in this case, the associated public key would also remain private. \"I know the preimage of this hash value\" : in this case, the proof would show that the prover knows the preimage but it would not reveal any information about the value of that preimage. \"This is the hash of a blockchain block that does not produce negative balances\" : in this case, the proof would not reveal any information about the amount, origin or destination of the transactions included in the block. Non-interactive zero-knowledge proofs \\(NIZK\\) are a particular type of zero-knowledge proofs in which the prover can generate the proof without interaction with the verifier. NIZK protocols are very suitable for Ethereum blockchain applications, because they allow a smart contract to act as a verifier . This way, anyone can generate a proof and send it as part of a transaction to the smart contract, which can perform some action depending on whether the proof is valid or not. In this context, the most preferable NIZK are zk-SNARK proofs \\(Zero-knowledge Succinct Non Interactive ARgument of Knowledge\\) , a set of non-interactive zero-knowledge protocols that have succinct proof size and sublinear verification time . The importance of these protocols is double: on the one hand, they help improve privacy guarantees, but on the other, their small proof size has been used in scalability solutions.","title":"Zero-knowledge proofs "},{"location":"background/background/#arithmetic-circuits","text":"Like most ZKPs, zk-SNARKs permits proving computational statements , but they cannot be applied to the computational problem directly, the statement first needs to be converted into the right form. Specifically, zk-SNARKs requires the computational statement to be modeled with an arithmetic circuit. Although it may not always be obvious how to do this conversion, most computational problems we care about can easily be converted into arithmetic circuits. An F_p -arithmetic circuit is a circuit consisting of set of wires that carry values from the field F_p and connect them to addition and multiplication gates modulo p . \ud83d\udc49 Remember that given a prime number p , the finite field F_p consists of the set of numbers {0,...,p-1} on which we can add and multiply these numbers modulo p . For example, the finite field F_7 consists of the set of numbers {0,...,6} on which we can add and multiply numbers modulo 7 . An easy way to understand how operating modulo 7 works, is to think of a clock of 7 hours in which we do not care about how many times the hands have turned the clock, only what time they mark. In other words, we only care about the reminder of dividing by 7. For instance: 15 modulo 7 = 1 , since 15 = 7 + 7 + 1 7 modulo 7 = 0 4*3 modulo 7 = 5 , since 4*3 = 12 = 7 + 5","title":"Arithmetic circuits "},{"location":"background/background/#signals-of-a-circuit","text":"So, an arithmetic circuit takes some input signals that are values between 0,...,p-1 and performs additions and multiplications between them modulo the prime p . The output of every addition and multiplication gate is considered an intermediate signal , except for the last gate of the circuit, the output of which , is the output signal of the circuit. To generate and validate zk-SNARK proofs in Ethereum , we need to work with F_p -arithmetic circuits, taking the prime: p = 21888242871839275222246405745257275088548364400416034343698204186575808495617 In the figure below, we have defined an F_7 -arithmetic circuit that performs the operation: out = a*b + c . The circuit has 5 signals: the signals a , b and c are input signals, d is an intermediate signal and the out signal is the output of the circuit.","title":"Signals of a circuit "},{"location":"background/background/#_1","text":"In order to use zk-SNARK protocols, we need to describe the relation between signals as a system of equations that relate variables with gates. From now on, the equations that describe the circuit will be called constraints , and you can think of them as conditions that signals of that circuit must satisfy.","title":"\u200b "},{"location":"background/background/#rank-1-constraint-system","text":"If we have an arithmetic circuit with signals s_1,...,s_n , then we define a constraint as an equation of the following form: (a_1*s_1 + ... + a_n*s_n) * (b_1*s_1 + ... + b_n*s_n) + (c_1*s_1 + ... + c_n*s_n) = 0 Note that constraint must be quadratic, linear or constant equations , and sometimes, by doing small modifications \\(like a change of variable or gathering two constraints\\) , it is possible to reduce the number of constraints or variables. In general, circuits will have several constraints \\(typically, one per multiplicative gate\\) . The set of constraints describing the circuit is called rank-1 constraint system \\(R1CS\\) : (a_11*s_1 + ... + a_1n*s_n)*(b_11*s_1 + ... + b_1n*s_n) + (c_11*s_1 + ... + c_1n*s_n) = 0 (a_21*s_1 + ... + a_2n*s_n)*(b_21*s_1 + ... + b_2n*s_n) + (c_21*s_1 + ... + c_1n*s_n) = 0 (a_31*s_1 + ... + a_3n*s_n)*(b_31*s_1 + ... + b_3n*s_n) + (c_31*s_1 + ... + c_1n*s_n) = 0 ... ... (a_m1*s_1 + ... + a_mn*s_n)*(b_m1*s_1 + ... + b_mn*s_n) + (c_m1*s_1 + ... + c_mn*s_n) = 0 Remember that operations inside the circuit are performed modulo a certain prime p . So, all equations above are defined modulo p . In the previous example, the R1CS of our circuit consists of the following two equations: d = a*b modulo 7 out = d+c modulo 7 In this case, by replacing directly the variable d , we can gather the two equations into a single one: out = a*b + c modulo 7 The nice thing about circuits, is that although most zero-knowledge protocols have an inherent complexity that can be overwhelming for many developers, the design of arithmetic circuits is clear and neat . \ud83d\udc49 With circom , you design your own circuits with your own constraints, and the compiler outputs the R1CS representation that you will need for your zero-knowledge proof. Zero-knowledge permits proving circuit satisfiability . What this means is, that you can prove that you know a set of signals that satisfy the circuit, or in other words, that you know a solution to the R1CS. This set of signals is called witness .","title":"Rank-1 constraint system "},{"location":"background/background/#witness","text":"Given a set of inputs, the calculation of the intermediate and output signals is pretty straightforward. So, given any set of inputs, we can always calculate the rest of signals. So, why should we talk about circuit satisfiability? The key aspect of zero-knowledge proofs, is that it allows you to compute these circuits without revealing information about the signals. For instance, imagine that in the previous circuit, the input a is a private key and the input b is the corresponding public key. You may be okay with revealing b but you certainly do not want to reveal a . If we define a as a private input, b , c as public inputs and out as a public output, with zero-knowledge we are able to prove, without revealing its value, that we know a private input a such that, for certain public values b , c and out , the equation a*b + c = out mod 7 holds. Note that we could easily deduce the value of a by isolating it from the other signals. It is important to design circuits that keep the privacy of the private inputs and prevent deducing them from the R1CS. An assignment of the signals is called a witness . For example, {a = 2, b = 6, c = -1, out = 4} would be a valid witness for the circuit. The assignment {a = 1, b = 2, c = 1, out = 0} would not be a valid witness, since it does not satisfy the equation a*b - c = out .","title":"Witness "},{"location":"background/background/#summary","text":"\u200b In summary, zk-SNARK proofs are an specific type of zero-knowledge proofs that allow you to prove that you know a set of signals \\(witness\\) that match all the constraints of a circuit without revealing any of the signals except the public inputs and the outputs.","title":"Summary "},{"location":"circom-language/basic-operators/","text":"Basic Operators Circom provides boolean, arithmetic, and bitwise operators. They have the standard semantics but the arithmetic operators applied to numeric values work modulo p. The precedence and association of the operators are like in Rust (defined here ). Expressions can be built using the next operators, but the conditional operator ?_:_ can only occur at the top level. Field Elements A field element is a value in the domain of Z/pZ, where p is the prime number set by default to p = 21888242871839275222246405745257275088548364400416034343698204186575808495617. As such, field elements are operated in arithmetic modulo p. The circom language is parametric to this number, and it can be changed without affecting the rest of the language (using GLOBAL_FIELD_P ). Conditional expressions Boolean_condition ? true_value : false_value var z = x>y? x : y; This conditional expression is not allowed in a nested form, hence can only be used at the top level. Boolean operators Next boolean operators are allowed: Operator Example Explanation && a && b Boolean operator AND || a || b Boolean operator OR ! ! a Boolean operator NEGATION Relational operators The definition of relational operators < , > , <= , >= , == , != depends on the mathematical function val(x) which is defined as follows: val(z) = z-p if p/2 +1 <= z < p val(z) = z, otherwise. According to this function, the definition of the relational operators is as follows: `x < y` is defined as val(x % p) < val(y % p) `x > y` is defined as val(x % p) > val(y % p) `x <= y` is defined as val(x % p) <= val(y % p) `x >= y` is defined as val(x % p) >= val(y % p) where <, >, <=, >= are the comparison of integers. Arithmetic operators All arithmetic operations work modulo p. We have the next operators: Operator Example Explanation + a + b Arithmetic addition modulo p - a - b Arithmetic subtraction modulo p * a * b Arithmetic multiplication modulo p ** a ** b Power modulo p / a / b Multiplication by the inverse modulo p \\ a \\ b Quotient of the integer division % a % b Remainder of the integer division There are operators that combine arithmetic operators with a final assignment. Operator Example Explanation += a += b Arithmetic addition modulo p and assignment -= a -= b Arithmetic subtraction modulo p and assignment *= a *= b Arithmetic multiplication modulo p and assignment **= a ** b Power modulo p and assignment /= a /= b Multiplication by the inverse modulo p and assignment \\= a \\= b Quotient of the integer division and assignment %= a %= b Remainder of the integer division and assignment ++ a++ Unit increment. Syntactic sugar for a += 1 -- a-- Unit decrement. Syntactic sugar for a -= 1 Bitwise operators All bitwise operators are performed modulo p. Operator Example Explanation & a & b Bitwise AND | a | b Bitwise OR ~ ~a Complement 254 bits ^ a ^ b XOR 254 bits >> a >> 4 Right shift operator << a << 4 Left shift operator The shift operations also work modulo p and are defined as follows (assuming p>=7). For all k with 0=< k <= p/2 (integer division) we have that x >> k = x/(2**k) x << k = (x*(2{**}k)~ & ~mask) % p where b is the number of significant bits of p and mask is 2{**}b - 1 . For all k with p/2 +1<= k < p we have that x >> k = x << (p-k) x << k = x >> (p-k) note that k is also the negative number k-p . There are operators that combine bitwise operators with a final assignment. Operator Example Explanation &= a &= b Bitwise AND and assignment |= a |= b Bitwise OR and assignment ~= ~=a Complement 254 bits and assignment ^= a ^= b XOR 254 bits and assignment >>= a >>= 4 Right shift operator and assignment <<= a <<= 4 Left shift operator and assignment Examples using operators from the circom library In the following, there are several examples using combinations of the previous operators. pragma circom 2.0.0; template IsZero() { signal input in; signal output out; signal inv; inv <-- in!=0 ? 1/in : 0; out <== -in*inv +1; in*out === 0; } component main {public [in]}= IsZero(); This template checks if the input signal in is 0 . In case it is, the value of output signal out is 1 . 0 , otherwise. Note here that we use the intermediate signal inv to compute the inverse of the value of in or 0 if it does not exist. If in is 0, then in*inv is 0, and the value of out is 1 . Otherwise, in*inv is always 1 , then out is 0 . pragma circom 2.0.0; template Num2Bits(n) { signal input in; signal output out[n]; var lc1=0; var e2=1; for (var i = 0; i<n; i++) { out[i] <-- (in >> i) & 1; out[i] * (out[i] -1 ) === 0; lc1 += out[i] * e2; e2 = e2+e2; } lc1 === in; } component main {public [in]}= Num2Bits(3); This templates returns a n-dimensional array with the value of in in binary. Line 7 uses the right shift >> and operator & to obtain at each iteration the i component of the array. Finally, line 12 adds the constraint lc1 = in to guarantee that the conversion is well done.","title":"Basic Operators"},{"location":"circom-language/basic-operators/#basic-operators","text":"Circom provides boolean, arithmetic, and bitwise operators. They have the standard semantics but the arithmetic operators applied to numeric values work modulo p. The precedence and association of the operators are like in Rust (defined here ). Expressions can be built using the next operators, but the conditional operator ?_:_ can only occur at the top level.","title":"Basic Operators"},{"location":"circom-language/basic-operators/#field-elements","text":"A field element is a value in the domain of Z/pZ, where p is the prime number set by default to p = 21888242871839275222246405745257275088548364400416034343698204186575808495617. As such, field elements are operated in arithmetic modulo p. The circom language is parametric to this number, and it can be changed without affecting the rest of the language (using GLOBAL_FIELD_P ).","title":"Field Elements"},{"location":"circom-language/basic-operators/#conditional-expressions","text":"Boolean_condition ? true_value : false_value var z = x>y? x : y; This conditional expression is not allowed in a nested form, hence can only be used at the top level.","title":"Conditional expressions"},{"location":"circom-language/basic-operators/#boolean-operators","text":"Next boolean operators are allowed: Operator Example Explanation && a && b Boolean operator AND || a || b Boolean operator OR ! ! a Boolean operator NEGATION","title":"Boolean operators"},{"location":"circom-language/basic-operators/#relational-operators","text":"The definition of relational operators < , > , <= , >= , == , != depends on the mathematical function val(x) which is defined as follows: val(z) = z-p if p/2 +1 <= z < p val(z) = z, otherwise. According to this function, the definition of the relational operators is as follows: `x < y` is defined as val(x % p) < val(y % p) `x > y` is defined as val(x % p) > val(y % p) `x <= y` is defined as val(x % p) <= val(y % p) `x >= y` is defined as val(x % p) >= val(y % p) where <, >, <=, >= are the comparison of integers.","title":"Relational operators"},{"location":"circom-language/basic-operators/#arithmetic-operators","text":"All arithmetic operations work modulo p. We have the next operators: Operator Example Explanation + a + b Arithmetic addition modulo p - a - b Arithmetic subtraction modulo p * a * b Arithmetic multiplication modulo p ** a ** b Power modulo p / a / b Multiplication by the inverse modulo p \\ a \\ b Quotient of the integer division % a % b Remainder of the integer division There are operators that combine arithmetic operators with a final assignment. Operator Example Explanation += a += b Arithmetic addition modulo p and assignment -= a -= b Arithmetic subtraction modulo p and assignment *= a *= b Arithmetic multiplication modulo p and assignment **= a ** b Power modulo p and assignment /= a /= b Multiplication by the inverse modulo p and assignment \\= a \\= b Quotient of the integer division and assignment %= a %= b Remainder of the integer division and assignment ++ a++ Unit increment. Syntactic sugar for a += 1 -- a-- Unit decrement. Syntactic sugar for a -= 1","title":"Arithmetic operators"},{"location":"circom-language/basic-operators/#bitwise-operators","text":"All bitwise operators are performed modulo p. Operator Example Explanation & a & b Bitwise AND | a | b Bitwise OR ~ ~a Complement 254 bits ^ a ^ b XOR 254 bits >> a >> 4 Right shift operator << a << 4 Left shift operator The shift operations also work modulo p and are defined as follows (assuming p>=7). For all k with 0=< k <= p/2 (integer division) we have that x >> k = x/(2**k) x << k = (x*(2{**}k)~ & ~mask) % p where b is the number of significant bits of p and mask is 2{**}b - 1 . For all k with p/2 +1<= k < p we have that x >> k = x << (p-k) x << k = x >> (p-k) note that k is also the negative number k-p . There are operators that combine bitwise operators with a final assignment. Operator Example Explanation &= a &= b Bitwise AND and assignment |= a |= b Bitwise OR and assignment ~= ~=a Complement 254 bits and assignment ^= a ^= b XOR 254 bits and assignment >>= a >>= 4 Right shift operator and assignment <<= a <<= 4 Left shift operator and assignment","title":"Bitwise operators"},{"location":"circom-language/basic-operators/#examples-using-operators-from-the-circom-library","text":"In the following, there are several examples using combinations of the previous operators. pragma circom 2.0.0; template IsZero() { signal input in; signal output out; signal inv; inv <-- in!=0 ? 1/in : 0; out <== -in*inv +1; in*out === 0; } component main {public [in]}= IsZero(); This template checks if the input signal in is 0 . In case it is, the value of output signal out is 1 . 0 , otherwise. Note here that we use the intermediate signal inv to compute the inverse of the value of in or 0 if it does not exist. If in is 0, then in*inv is 0, and the value of out is 1 . Otherwise, in*inv is always 1 , then out is 0 . pragma circom 2.0.0; template Num2Bits(n) { signal input in; signal output out[n]; var lc1=0; var e2=1; for (var i = 0; i<n; i++) { out[i] <-- (in >> i) & 1; out[i] * (out[i] -1 ) === 0; lc1 += out[i] * e2; e2 = e2+e2; } lc1 === in; } component main {public [in]}= Num2Bits(3); This templates returns a n-dimensional array with the value of in in binary. Line 7 uses the right shift >> and operator & to obtain at each iteration the i component of the array. Finally, line 12 adds the constraint lc1 = in to guarantee that the conversion is well done.","title":"Examples using operators from the circom library"},{"location":"circom-language/comment-lines/","text":"Comment Lines In circom, you can place comments in your source code. These comment lines will be ignored by the compiler. Comments help programmer reading your source code to better understand it. Adding comments to your code is a highly recommended practice. The comment lines allowed in circom 2.0 are similar to other programming languages like C or C++. You can write comments on a single line by using // : //Using this, we can comment a line. You can also write a comment at the end of a code line using // : template example(){ signal input in; //This is an input signal. signal output out; //This is an output signal. } Finally, you can write comments that span multiple lines using /* and */ : /* All these lines will be ignored by the compiler. */","title":"Comment Lines"},{"location":"circom-language/comment-lines/#comment-lines","text":"In circom, you can place comments in your source code. These comment lines will be ignored by the compiler. Comments help programmer reading your source code to better understand it. Adding comments to your code is a highly recommended practice. The comment lines allowed in circom 2.0 are similar to other programming languages like C or C++. You can write comments on a single line by using // : //Using this, we can comment a line. You can also write a comment at the end of a code line using // : template example(){ signal input in; //This is an input signal. signal output out; //This is an output signal. } Finally, you can write comments that span multiple lines using /* and */ : /* All these lines will be ignored by the compiler. */","title":"Comment Lines"},{"location":"circom-language/constraint-generation/","text":"Constraint Generation To understand the constructive part of circom, we need to consider the following type of expressions: Constant values : only a constant value is allowed. Linear expression : an expression where only addition is used. It can also be written using multiplication of variables by constants. For instance, the expression 2*x + 3*y + 2 is allowed, as it is equivalent to x + x + y + y + y + 2 . Quadratic expression : it is obtained by allowing a multiplication between two linear expressions and addition of a linear expression: A*B - C, where A, B and C are linear expressions. For instance, (2*x + 3*y + 2) * (x+y) + 6*x + y \u2013 2 . Non quadratic expressions : any arithmetic expression which is not of the previous kind. circom allows programmers to define the constraints that define the arithmetic circuit. All constraints must be quadratic of the form A*B + C = 0, where A, B and C are linear combinations of signals. circom will apply some minor transformations on the defined constraints in order to meet the format A*B + C = 0: Moves from one side of the equality to the other. Applications of commutativity of addition. Multiplication (or division) by constants. A constraint is imposed with the operator === , which creates the simplified form of the given equality constraint. a*(a-1) === 0; Adding such constraint also implies adding an assert statement in the witness code generation. Constraint generation can be combined with signal assignment with the operator <== with the signal to be assigned on the left hand side of the operator. out <== 1 - a*b; Which is equivalent to: out === 1 \u2013 a*b; out <-- 1 - a*b; As mentioned before, assigning a value to a signal using <-- and --> is considered dangerous and should, in general, be combined with adding constraints with === , which describe by means of constraints which the assigned values are. For example: a <-- b/c; a*c === b; In the constructive phase, a variable can contain arithmetic expressions that are built using multiplication, addition, and other variables or signals and field values. Only quadratic expressions are allowed to be included in constraints. Other arithmetic expressions beyond quadratic or using other arithmetic operators like division or power are not allowed as constraints. template multi3() { signal input in; signal input in2; signal input in3; signal output out; out <== in*in2*in3; } This template produces the error \"Non quadratic constraints are not allowed!\", since it introduces the constraint out === in*in2*in3 which is NOT quadratic. The following example shows the generation of expressions: signal input a; signal output b; var x = a*a; x += 3; b <== x; The last instruction produces the constraint b === a * a + 3 .","title":"Constraint Generation"},{"location":"circom-language/constraint-generation/#constraint-generation","text":"To understand the constructive part of circom, we need to consider the following type of expressions: Constant values : only a constant value is allowed. Linear expression : an expression where only addition is used. It can also be written using multiplication of variables by constants. For instance, the expression 2*x + 3*y + 2 is allowed, as it is equivalent to x + x + y + y + y + 2 . Quadratic expression : it is obtained by allowing a multiplication between two linear expressions and addition of a linear expression: A*B - C, where A, B and C are linear expressions. For instance, (2*x + 3*y + 2) * (x+y) + 6*x + y \u2013 2 . Non quadratic expressions : any arithmetic expression which is not of the previous kind. circom allows programmers to define the constraints that define the arithmetic circuit. All constraints must be quadratic of the form A*B + C = 0, where A, B and C are linear combinations of signals. circom will apply some minor transformations on the defined constraints in order to meet the format A*B + C = 0: Moves from one side of the equality to the other. Applications of commutativity of addition. Multiplication (or division) by constants. A constraint is imposed with the operator === , which creates the simplified form of the given equality constraint. a*(a-1) === 0; Adding such constraint also implies adding an assert statement in the witness code generation. Constraint generation can be combined with signal assignment with the operator <== with the signal to be assigned on the left hand side of the operator. out <== 1 - a*b; Which is equivalent to: out === 1 \u2013 a*b; out <-- 1 - a*b; As mentioned before, assigning a value to a signal using <-- and --> is considered dangerous and should, in general, be combined with adding constraints with === , which describe by means of constraints which the assigned values are. For example: a <-- b/c; a*c === b; In the constructive phase, a variable can contain arithmetic expressions that are built using multiplication, addition, and other variables or signals and field values. Only quadratic expressions are allowed to be included in constraints. Other arithmetic expressions beyond quadratic or using other arithmetic operators like division or power are not allowed as constraints. template multi3() { signal input in; signal input in2; signal input in3; signal output out; out <== in*in2*in3; } This template produces the error \"Non quadratic constraints are not allowed!\", since it introduces the constraint out === in*in2*in3 which is NOT quadratic. The following example shows the generation of expressions: signal input a; signal output b; var x = a*a; x += 3; b <== x; The last instruction produces the constraint b === a * a + 3 .","title":"Constraint Generation"},{"location":"circom-language/control-flow/","text":"Control Flow We have standard constructions for defining the control flow of the program. Conditional statement: if-then-else if ( boolean_condition ) block_of_code else block_of_code The else part is optional. When omitted, it means \u201celse do nothing\u201d. var x = 0; var y = 1; if (x >= 0) { x = y + 1; y += 1; } else { y = x; } Loop statement: for for ( initialization_code ; boolean_condition ; step_code ) block_of_code If the initialization_code includes a var declaration then its scope is reduced to the for statement and hence, using it later on (without defining it again) will produce a compilation error. var y = 0; for(var i = 0; i < 100; i++){ y++; } Loop statement: while while ( boolean_condition ) block_of_code It executes the block of code while the condition holds. The condition is checked every time before executing the block of code. var y = 0; var i = 0; while(i < 100){ i++; y += y; } Important : when constraints are generated in any block inside an if-then-else or loop statement, the condition cannot be unknown (see Unknowns ). This is because the constraint generation must be unique and cannot depend on unknown input signals. In case the expression in the condition is unknown and some constraint is generated, the compiler will generate the next error message: \" There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase \". pragma circom 2.0.0; template A(){} template wrong(N1){ signal input in; component c; if(in > N1){ c = A(); } } component main {public [in]} = wrong(1); In this example, the condition depends on the input signal in whose value is unknown at compilation time. Let us also notice that if the body of the statement does not involve any signal or component; or a constraint does not depend on a value involved with unknown values, then the compilation will succeed as it can be seen in the next example. template right(N){ signal input in; var x = 2; var t = 5; if(in > N){ t = 2; } } This template is correct, since no constraint depends on the unknown value of in . template right(N1,N2){ signal input in; var x = 2; var t = 5; if(N1 > N2){ t = 2; } x === t; } This template is correct since the values of variables involved in the constraint only depend on known values of parameter N1 and N2 . Important : Another compilation error is generated when the content of a var depends on some unknown condition: that is when the var takes its value inside an if-then-else or loop statement with an unknown condition. Then, the content of the variable is a non-quadratic expression and, as such, cannot be used in the generation of a constraint. template wrong(){ signal input in; var x; var t = 5; if(in > 3){ t = 2; } x === t; } This template produces a compilation error, since the value of variable t involved in the last constraint depends on the unknown value of variable in . The control flow of the computations is like in other imperative languages, but the instantiation of components may not follow the sequential structure of the code because component instantiation will not be triggered until all input signals have a concrete value assigned. template mult(){ signal input in[2]; signal output out; out <== in[0] * in[1]; } template mult4(){ signal input in[4]; component comp1 = mult(); component comp2 = mult(); comp1.in[0] = in[0]; comp2.in[0] = in[1]; comp2.in[1] = in[2]; comp1.in[1] = in[3]; } In this example, comp2 is instantiated before comp1 , since comp2 's input signals have concrete values before comp1 's input signals. Consequently, comp2.out obtains the value after the execution of line 13, whereas comp1.out obtains it after the execution of line 14.","title":"Control Flow"},{"location":"circom-language/control-flow/#control-flow","text":"We have standard constructions for defining the control flow of the program.","title":"Control Flow"},{"location":"circom-language/control-flow/#conditional-statement-if-then-else","text":"if ( boolean_condition ) block_of_code else block_of_code The else part is optional. When omitted, it means \u201celse do nothing\u201d. var x = 0; var y = 1; if (x >= 0) { x = y + 1; y += 1; } else { y = x; }","title":"Conditional statement: if-then-else"},{"location":"circom-language/control-flow/#loop-statement-for","text":"for ( initialization_code ; boolean_condition ; step_code ) block_of_code If the initialization_code includes a var declaration then its scope is reduced to the for statement and hence, using it later on (without defining it again) will produce a compilation error. var y = 0; for(var i = 0; i < 100; i++){ y++; }","title":"Loop statement: for"},{"location":"circom-language/control-flow/#loop-statement-while","text":"while ( boolean_condition ) block_of_code It executes the block of code while the condition holds. The condition is checked every time before executing the block of code. var y = 0; var i = 0; while(i < 100){ i++; y += y; } Important : when constraints are generated in any block inside an if-then-else or loop statement, the condition cannot be unknown (see Unknowns ). This is because the constraint generation must be unique and cannot depend on unknown input signals. In case the expression in the condition is unknown and some constraint is generated, the compiler will generate the next error message: \" There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase \". pragma circom 2.0.0; template A(){} template wrong(N1){ signal input in; component c; if(in > N1){ c = A(); } } component main {public [in]} = wrong(1); In this example, the condition depends on the input signal in whose value is unknown at compilation time. Let us also notice that if the body of the statement does not involve any signal or component; or a constraint does not depend on a value involved with unknown values, then the compilation will succeed as it can be seen in the next example. template right(N){ signal input in; var x = 2; var t = 5; if(in > N){ t = 2; } } This template is correct, since no constraint depends on the unknown value of in . template right(N1,N2){ signal input in; var x = 2; var t = 5; if(N1 > N2){ t = 2; } x === t; } This template is correct since the values of variables involved in the constraint only depend on known values of parameter N1 and N2 . Important : Another compilation error is generated when the content of a var depends on some unknown condition: that is when the var takes its value inside an if-then-else or loop statement with an unknown condition. Then, the content of the variable is a non-quadratic expression and, as such, cannot be used in the generation of a constraint. template wrong(){ signal input in; var x; var t = 5; if(in > 3){ t = 2; } x === t; } This template produces a compilation error, since the value of variable t involved in the last constraint depends on the unknown value of variable in . The control flow of the computations is like in other imperative languages, but the instantiation of components may not follow the sequential structure of the code because component instantiation will not be triggered until all input signals have a concrete value assigned. template mult(){ signal input in[2]; signal output out; out <== in[0] * in[1]; } template mult4(){ signal input in[4]; component comp1 = mult(); component comp2 = mult(); comp1.in[0] = in[0]; comp2.in[0] = in[1]; comp2.in[1] = in[2]; comp1.in[1] = in[3]; } In this example, comp2 is instantiated before comp1 , since comp2 's input signals have concrete values before comp1 's input signals. Consequently, comp2.out obtains the value after the execution of line 13, whereas comp1.out obtains it after the execution of line 14.","title":"Loop statement: while"},{"location":"circom-language/custom-templates-snarkjs/","text":"Custom templates in snarkjs snarkjs provides an implementation of the PLONK's zkSNARK. An extension of the scheme, turbo-PLONK , allows the definition of the so called custom gates: more general transition gates than the ones defined by default for the regular PLONK zkSNARK, that allows the circuit's designer to, maybe, reduce the number of used gates, probably resulting in shorter proofs size or verification times. This document will contain a list of the custom gates implemented in snarkjs that can me used in the circom language. Note that the list may grow over time with the new implementations from the iden3 collaborators or thanks to contributions from the community. List of custom gates implemented in snarkjs At the moment there are no custom gates implemented in snarkjs yet.","title":"Custom templates in [snarkjs](../index.md#snarkjs)"},{"location":"circom-language/custom-templates-snarkjs/#custom-templates-in-snarkjs","text":"snarkjs provides an implementation of the PLONK's zkSNARK. An extension of the scheme, turbo-PLONK , allows the definition of the so called custom gates: more general transition gates than the ones defined by default for the regular PLONK zkSNARK, that allows the circuit's designer to, maybe, reduce the number of used gates, probably resulting in shorter proofs size or verification times. This document will contain a list of the custom gates implemented in snarkjs that can me used in the circom language. Note that the list may grow over time with the new implementations from the iden3 collaborators or thanks to contributions from the community.","title":"Custom templates in snarkjs"},{"location":"circom-language/custom-templates-snarkjs/#list-of-custom-gates-implemented-in-snarkjs","text":"At the moment there are no custom gates implemented in snarkjs yet.","title":"List of custom gates implemented in snarkjs"},{"location":"circom-language/data-types/","text":"Data types The basic var types in circom are: Field element values : integer values modulo the prime number p (see Signals ). This is the default type for all signals and basic variables. Arrays : they can hold a finite number of elements (known at compilation time) of the same type (signal, var, or the same type of components or arrays again). The elements are numbered from zero on and can be accessed using the corresponding index of their position. Array access is made using square brackets. Declaration of an array of a given type is made by adding [] aside of the variable identifier and including the size between the brackets (which should be defined using constant values and/or numeric parameters of templates). The access and the declaration should be consistent with their type and hence we access and declare with m[i][j], since m[i] is an array. Examples of declarations with and without initialization: var x[3] = [2,8,4]; var z[n+1]; // where n is a parameter of a template var dbl[16][2] = base; var y[5] = someFunction(n); The notation m[i,j] for arrays of arrays (matrices) is not allowed. On the other hand, the following case will produce a compilation error, since the size of the array should be explicitly given; var z = [2,8,4]; Finally, the type of signals needs to be declared as they cannot be assigned globally as an array. They are assigned by position. signal input in[3]; signal output out[2]; signal intermediate[4]; An array of components must be instantiated with the same template with (optionally) different parameters. pragma circom 2.0.0; template fun(N){ signal output out; out <== N; } template all(N){ component c[N]; for(var i = 0; i < N; i++){ c[i] = fun(i); } } component main = all(5); Consequently, the next code will produce the following compilation error: \" c[i] = fun \\(i\\) -> Assignee and assigned types do not match\". pragma circom 2.0.0; template fun(N){ signal output out; out <== N; } template fun2(N){ signal output out; out <== N; } template all(N){ component c[N]; for(var i = 0; i < N; i++){ if(i < N) c[i] = fun(i); else c[i] = fun2(i); } } component main = all(5);","title":"Data Types"},{"location":"circom-language/data-types/#data-types","text":"The basic var types in circom are: Field element values : integer values modulo the prime number p (see Signals ). This is the default type for all signals and basic variables. Arrays : they can hold a finite number of elements (known at compilation time) of the same type (signal, var, or the same type of components or arrays again). The elements are numbered from zero on and can be accessed using the corresponding index of their position. Array access is made using square brackets. Declaration of an array of a given type is made by adding [] aside of the variable identifier and including the size between the brackets (which should be defined using constant values and/or numeric parameters of templates). The access and the declaration should be consistent with their type and hence we access and declare with m[i][j], since m[i] is an array. Examples of declarations with and without initialization: var x[3] = [2,8,4]; var z[n+1]; // where n is a parameter of a template var dbl[16][2] = base; var y[5] = someFunction(n); The notation m[i,j] for arrays of arrays (matrices) is not allowed. On the other hand, the following case will produce a compilation error, since the size of the array should be explicitly given; var z = [2,8,4]; Finally, the type of signals needs to be declared as they cannot be assigned globally as an array. They are assigned by position. signal input in[3]; signal output out[2]; signal intermediate[4]; An array of components must be instantiated with the same template with (optionally) different parameters. pragma circom 2.0.0; template fun(N){ signal output out; out <== N; } template all(N){ component c[N]; for(var i = 0; i < N; i++){ c[i] = fun(i); } } component main = all(5); Consequently, the next code will produce the following compilation error: \" c[i] = fun \\(i\\) -> Assignee and assigned types do not match\". pragma circom 2.0.0; template fun(N){ signal output out; out <== N; } template fun2(N){ signal output out; out <== N; } template all(N){ component c[N]; for(var i = 0; i < N; i++){ if(i < N) c[i] = fun(i); else c[i] = fun2(i); } } component main = all(5);","title":"Data types"},{"location":"circom-language/functions/","text":"Functions In circom, functions define generic abstract pieces of code that can perform some computations to obtain a value or an expression to be returned. function funid ( param1, ... , paramn ) { ..... return x; } Functions compute numeric (or arrays of) values or expressions. Functions can be recursive. Consider the next function from the circom library. /* This function calculates the number of extra bits in the output to do the full sum. */ function nbits(a) { var n = 1; var r = 0; while (n-1<a) { r++; n *= 2; } return r; } Functions cannot declare signals or generate constraints (use templates if you need so). The next function produces the error message: \"Template operator found\". function nbits(a) { signal input in; //This is not allowed. var n = 1; var r = 0; while (n-1<a) { r++; n *= 2; } r === a; //This is also not allowed. return r; } As usual, there can be many return statements, but every execution trace must end in a return statement (otherwise, a compile error will be produced). The execution of the return statement returns the control to the caller of the function. function example(N){ if(N >= 0){ return 1;} // else{ return 0;} } The compilation of function example produces the next error message: \"In example there are paths without return\".","title":"Functions"},{"location":"circom-language/functions/#functions","text":"In circom, functions define generic abstract pieces of code that can perform some computations to obtain a value or an expression to be returned. function funid ( param1, ... , paramn ) { ..... return x; } Functions compute numeric (or arrays of) values or expressions. Functions can be recursive. Consider the next function from the circom library. /* This function calculates the number of extra bits in the output to do the full sum. */ function nbits(a) { var n = 1; var r = 0; while (n-1<a) { r++; n *= 2; } return r; } Functions cannot declare signals or generate constraints (use templates if you need so). The next function produces the error message: \"Template operator found\". function nbits(a) { signal input in; //This is not allowed. var n = 1; var r = 0; while (n-1<a) { r++; n *= 2; } r === a; //This is also not allowed. return r; } As usual, there can be many return statements, but every execution trace must end in a return statement (otherwise, a compile error will be produced). The execution of the return statement returns the control to the caller of the function. function example(N){ if(N >= 0){ return 1;} // else{ return 0;} } The compilation of function example produces the next error message: \"In example there are paths without return\".","title":"Functions"},{"location":"circom-language/identifiers/","text":"Identifiers Any non-reserved keyword that starts with any number of \u201c_ \u201d followed by an ASCII alphabetic character and followed by any number of alphabetic or numeric chars, \u201c_\u201d or \u201c$\u201d can be used as identifier. Examples of identifiers are the following: signal input _in; var o_u_t; var o$o;","title":"Identifiers"},{"location":"circom-language/identifiers/#identifiers","text":"Any non-reserved keyword that starts with any number of \u201c_ \u201d followed by an ASCII alphabetic character and followed by any number of alphabetic or numeric chars, \u201c_\u201d or \u201c$\u201d can be used as identifier. Examples of identifiers are the following: signal input _in; var o_u_t; var o$o;","title":"Identifiers"},{"location":"circom-language/include/","text":"Include Templates, like other code, can be found in other files like in libraries. In order to use code in other files, we have to include them in our program by using the keyword include, with the corresponding name of the file (.circom extension is the default). include \"montgomery.circom\"; include \"mux3.circom\"; include \"babyjub.circom\"; This piece of code includes the files montgomery.circom , mux3.circom and babyjub.circom from the circom library.","title":"Include"},{"location":"circom-language/include/#include","text":"Templates, like other code, can be found in other files like in libraries. In order to use code in other files, we have to include them in our program by using the keyword include, with the corresponding name of the file (.circom extension is the default). include \"montgomery.circom\"; include \"mux3.circom\"; include \"babyjub.circom\"; This piece of code includes the files montgomery.circom , mux3.circom and babyjub.circom from the circom library.","title":"Include"},{"location":"circom-language/pragma/","text":"Pragma Version pragma All files with .circom extension should start with a first pragma instruction specifying the compiler version, like this: pragma circom xx.yy.zz; This is to ensure that the circuit is compatible with the compiler version indicated after the pragma instruction. Otherwise, the compiler throws a warning. If a file does not contain this instruction, it is assumed that the code is compatible with the latest compiler's version and a warning is thrown. Custom templates pragma Since circom 2.0.6, the language allows the definition of custom templates (see this for more information). This pragma allows the circom programmer to easily tell if it's using custom templates: if any file declaring a custom template or including a file declaring any custom template doesn't use this pragma , the compiler will produce an error. Moreover, it will inform the programmer about which files should include this pragma. To use it simply add the following instruction at the beginning (and after the version pragma ) of the .circom files that needs it: pragma custom_templates;","title":"Pragma"},{"location":"circom-language/pragma/#pragma","text":"","title":"Pragma"},{"location":"circom-language/pragma/#version-pragma","text":"All files with .circom extension should start with a first pragma instruction specifying the compiler version, like this: pragma circom xx.yy.zz; This is to ensure that the circuit is compatible with the compiler version indicated after the pragma instruction. Otherwise, the compiler throws a warning. If a file does not contain this instruction, it is assumed that the code is compatible with the latest compiler's version and a warning is thrown.","title":"Version pragma"},{"location":"circom-language/pragma/#custom-templates-pragma","text":"Since circom 2.0.6, the language allows the definition of custom templates (see this for more information). This pragma allows the circom programmer to easily tell if it's using custom templates: if any file declaring a custom template or including a file declaring any custom template doesn't use this pragma , the compiler will produce an error. Moreover, it will inform the programmer about which files should include this pragma. To use it simply add the following instruction at the beginning (and after the version pragma ) of the .circom files that needs it: pragma custom_templates;","title":"Custom templates pragma"},{"location":"circom-language/reserved-keywords/","text":"Reserved Keywords The list of reserved keywords is the following: signal: Declare a new signal. input: Declare the signal as input. output: Declare the signal as output. public: Declare the signal as public. template: Define a new circuit. component: Instantiate a template. var: Declare a new integer variable. function: Define a new function. return: Return from function. if: Branch based on the result of a conditional expression. else: Fallback for if control flow construct. for: Loop conditionally based on the result of an expression. while: Loop conditionally based on the result of an expression. do: Loop conditionally based on the result of an expression. log: Print the result of the evaluation. assert: Check the condition at construction time. include: Include code of the indicated file. pragma circom : Instruction to check the compiler version. pragma custom_templates : Instruction to indicate the usage of custom templates.","title":"Reserved-keywords"},{"location":"circom-language/reserved-keywords/#reserved-keywords","text":"The list of reserved keywords is the following: signal: Declare a new signal. input: Declare the signal as input. output: Declare the signal as output. public: Declare the signal as public. template: Define a new circuit. component: Instantiate a template. var: Declare a new integer variable. function: Define a new function. return: Return from function. if: Branch based on the result of a conditional expression. else: Fallback for if control flow construct. for: Loop conditionally based on the result of an expression. while: Loop conditionally based on the result of an expression. do: Loop conditionally based on the result of an expression. log: Print the result of the evaluation. assert: Check the condition at construction time. include: Include code of the indicated file. pragma circom : Instruction to check the compiler version. pragma custom_templates : Instruction to indicate the usage of custom templates.","title":"Reserved Keywords"},{"location":"circom-language/scoping/","text":"Scoping Circom has static scoping like C and Rust. However, we have that signals and components must have global scoping and hence they should be defined at the top-level block of the template that defines them. pragma circom 2.0.0; template Multiplier2 (N) { //Declaration of signals. signal input in; signal output out; //Statements. out <== in; signal input x; if(N > 0){ signal output out2; out2 <== x; } } component main = Multiplier2(5); Signal out2 must be declared at the top-level block. The next compilation error is produced: \" out2 is outside the initial scope\" . Regarding visibility, a signal x of component c is also visible in the template t that has declared c, using the notation c.x. No access to signals of nested sub-components is allowed. For instance, if c is built using another component d, the signals of d cannot be accessed from t. This can be seen in the next code: pragma circom 2.0.0; template d(){ signal output x; x <== 1; } template c(){ signal output out2; out2 <== 2; component comp2 = d(); } template t(){ signal out; component c3 = c(); out <== c3.comp2.x; } component main = t(); This code produces a compilation error since we cannot access comp2 of component c3 . A var can be defined at any block and its visibility is reduced to the block like in C or Rust.","title":"Scoping"},{"location":"circom-language/scoping/#scoping","text":"Circom has static scoping like C and Rust. However, we have that signals and components must have global scoping and hence they should be defined at the top-level block of the template that defines them. pragma circom 2.0.0; template Multiplier2 (N) { //Declaration of signals. signal input in; signal output out; //Statements. out <== in; signal input x; if(N > 0){ signal output out2; out2 <== x; } } component main = Multiplier2(5); Signal out2 must be declared at the top-level block. The next compilation error is produced: \" out2 is outside the initial scope\" . Regarding visibility, a signal x of component c is also visible in the template t that has declared c, using the notation c.x. No access to signals of nested sub-components is allowed. For instance, if c is built using another component d, the signals of d cannot be accessed from t. This can be seen in the next code: pragma circom 2.0.0; template d(){ signal output x; x <== 1; } template c(){ signal output out2; out2 <== 2; component comp2 = d(); } template t(){ signal out; component c3 = c(); out <== c3.comp2.x; } component main = t(); This code produces a compilation error since we cannot access comp2 of component c3 . A var can be defined at any block and its visibility is reduced to the block like in C or Rust.","title":"Scoping"},{"location":"circom-language/signals/","text":"Signals & Variables The arithmetic circuits built using circom operate on signals, which contain field elements in Z/pZ. Signals can be named with an identifier or can be stored in arrays and declared using the keyword signal. Signals can be defined as input or output, and are considered intermediate signals otherwise. signal input in; signal output out[N]; signal inter; This small example declares an input signal with identifier in , an N-dimension array of output signals with identifier out and an intermediate signal with identifier inter . Signals are always considered private. The programmer can distinguish between public and private signals only when defining the main component, by providing the list of public input signals. pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out; out <== in1 * in2; } component main {public [in1,in2]} = Multiplier2(); Since circom 2.0.4, it is also allowed the initialization of intermediate and outputs signals right after their declaration. Then, the previous example can be rewritten as follows: pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out <== in1 * in2; } component main {public [in1,in2]} = Multiplier2(); This example declares input signals in1 and in2 of the main component as public signals. In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of signals are all private and cannot be made public. Thus, from the programmer's point of view, only public input and output signals are visible from outside the circuit, and hence no intermediate signal can be accessed. pragma circom 2.0.0; template A(){ signal input in; signal outA; //We do not declare it as output. outA <== in; } template B(){ //Declaration of signals signal output out; component comp = A(); out <== comp.outA; } component main = B(); This code produces a compilation error since signal outA is not declared as an output signal, then it cannot be accessed and assigned to signal out . Signals are immutable, which means that once they have a value assigned, this value cannot be changed any more. Hence, if a signal is assigned twice, a compilation error is generated. This can be seen in the next example where signal out is assigned twice, producing a compilation error. pragma circom 2.0.0; template A(){ signal input in; signal output outA; outA <== in; } template B(){ //Declaration of signals signal output out; out <== 0; component comp = A(); comp.in <== 0; out <== comp.outA; } component main = B(); At compilation time, the content of a signal is always considered unknown (see Unknowns ), even if a constant is already assigned to them. The reason for that is to provide a precise \\(decidable\\) definition of which constructions are allowed and which are not, without depending on the power of the compiler to detect whether a signal has always a constant value or not. pragma circom 2.0.0; template A(){ signal input in; signal output outA; var i = 0; var out; while (i < in){ out++; i++; } outA <== out; } template B(){ component a = A(); a.in <== 3; } component main = B(); This example produces a compilation error since value of signal outA depends on the value of signal in , even though, such a value is the constant 3. Signals can only be assigned using the operations <-- or <== (see Basic operators ) with the signal on the left hand side and and --> or ==> (see Basic operators ) with the signal on the right hand side. The safe options are <== and ==> , since they assign values and also generate constraints at the same time. Using <-- and --> is, in general, dangerous and should only be used when the assigned expression cannot be included in a constraint, like in the following example. out[k] <-- (in >> k) & 1;","title":"Signals"},{"location":"circom-language/signals/#signals-variables","text":"The arithmetic circuits built using circom operate on signals, which contain field elements in Z/pZ. Signals can be named with an identifier or can be stored in arrays and declared using the keyword signal. Signals can be defined as input or output, and are considered intermediate signals otherwise. signal input in; signal output out[N]; signal inter; This small example declares an input signal with identifier in , an N-dimension array of output signals with identifier out and an intermediate signal with identifier inter . Signals are always considered private. The programmer can distinguish between public and private signals only when defining the main component, by providing the list of public input signals. pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out; out <== in1 * in2; } component main {public [in1,in2]} = Multiplier2(); Since circom 2.0.4, it is also allowed the initialization of intermediate and outputs signals right after their declaration. Then, the previous example can be rewritten as follows: pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out <== in1 * in2; } component main {public [in1,in2]} = Multiplier2(); This example declares input signals in1 and in2 of the main component as public signals. In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of signals are all private and cannot be made public. Thus, from the programmer's point of view, only public input and output signals are visible from outside the circuit, and hence no intermediate signal can be accessed. pragma circom 2.0.0; template A(){ signal input in; signal outA; //We do not declare it as output. outA <== in; } template B(){ //Declaration of signals signal output out; component comp = A(); out <== comp.outA; } component main = B(); This code produces a compilation error since signal outA is not declared as an output signal, then it cannot be accessed and assigned to signal out . Signals are immutable, which means that once they have a value assigned, this value cannot be changed any more. Hence, if a signal is assigned twice, a compilation error is generated. This can be seen in the next example where signal out is assigned twice, producing a compilation error. pragma circom 2.0.0; template A(){ signal input in; signal output outA; outA <== in; } template B(){ //Declaration of signals signal output out; out <== 0; component comp = A(); comp.in <== 0; out <== comp.outA; } component main = B(); At compilation time, the content of a signal is always considered unknown (see Unknowns ), even if a constant is already assigned to them. The reason for that is to provide a precise \\(decidable\\) definition of which constructions are allowed and which are not, without depending on the power of the compiler to detect whether a signal has always a constant value or not. pragma circom 2.0.0; template A(){ signal input in; signal output outA; var i = 0; var out; while (i < in){ out++; i++; } outA <== out; } template B(){ component a = A(); a.in <== 3; } component main = B(); This example produces a compilation error since value of signal outA depends on the value of signal in , even though, such a value is the constant 3. Signals can only be assigned using the operations <-- or <== (see Basic operators ) with the signal on the left hand side and and --> or ==> (see Basic operators ) with the signal on the right hand side. The safe options are <== and ==> , since they assign values and also generate constraints at the same time. Using <-- and --> is, in general, dangerous and should only be used when the assigned expression cannot be included in a constraint, like in the following example. out[k] <-- (in >> k) & 1;","title":"Signals &amp; Variables"},{"location":"circom-language/templates-and-components/","text":"Templates & Components Templates The mechanism to create generic circuits in Circom is the so-called templates. They are normally parametric on some values that must be instantiated when the template is used. The instantiation of a template is a new circuit object, which can be used to compose other circuits, so as part of larger circuits. Since templates define circuits by instantiation, they have their own signals \\(input, output, etc\\) . template tempid ( param_1, ... , param_n ) { signal input a; signal output b; ..... } Templates cannot include local functions or template definitions. Assigning a value to an input signal inside the same template where it has been defined also generates the error \"Exception caused by invalid assignment\" as can be seen in the next example. pragma circom 2.0.0; template wrong (N) { signal input a; signal output b; a <== N; } component main = wrong(1); The instantiation of a template is made using the keyword component and by providing the necessary parameters. component c = tempid(v1,...,vn); The values of the parameters should be known constants at compile time. The next code produces this compilation error message: \"Every component instantiation must be resolved during the constraint generation phase\". pragma circom 2.0.0; template A(N1,N2){ signal input in; signal output out; out <== N1 * in * N2; } template wrong (N) { signal input a; signal output b; component c = A(a,N); } component main {public [a]} = wrong(1); Regarding the signals defined in the template that will be part of the component, the following compiler messages will be generated if we use the option --inspect to compile the code: If a signal is not used in any constraint, a warning message will be generated. Moreover, if it is an input signal x then the compiler would suggest adding a constraint of the form x * 0 === 0; pragma circom 2.0.0; template A(N){ signal input in; signal intermediate; signal output out; intermediate <== 1; out <== intermediate; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"In template \"A \\(1\\) \". Unconstrained signal. \"in\" = Maybe use: in*0 === 0\" If an intermediary signal is used only in one constraint, a hint message will be generated. pragma circom 2.0.0; template A(N){ signal input in; signal inter; inter <== 1; signal output out; out <== in; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"_In template \"A \\(1\\) \". One constraint intermediate: \"inter\" = Maybe use: inter*0 === 0\". If there is no output signal a warning message will be generated. pragma circom 2.0.0; template A(N){ signal input in; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"There is no output signal.\" . Components A component defines an arithmetic circuit and, as such, it receives N input signals and produces M output signals and K intermediate signals. Additionally, it can produce a set of constraints. In order to access the input or output signals of a component, we will use dot notation . No other signals are visible outside the component. c.a <== y*z-1; var x; x = c.b; The component instantiation will not be triggered until all its input signals are assigned to concrete values. Therefore the instantiation might be delayed and hence the component creation instruction does not imply the execution of the component object, but the creation of the instantiation process that will be completed when all the inputs are set. The output signals of a component can only be used when all inputs are set, otherwise a compiler error is generated. For instance, the following piece of code would result in an error: pragma circom 2.0.0; template Internal() { signal input in[2]; signal output out; out <== in[0]*in[1]; } template Main() { signal input in[2]; signal output out; component c = Internal (); c.in[0] <== in[0]; c.out ==> out; // c.in[1] is not assigned yet c.in[1] <== in[1]; // this line should be placed before calling c.out } component main = Main(); Components are immutable (like signals). A component can be declared first and initialized in a second step. If there are several initialization instructions (in different execution paths) they all need to be instantiations of the same template (maybe with different values for the parameters). template A(N){ signal input in; signal output out; out <== in; } template C(N){ signal output out; out <== N; } template B(N){ signal output out; component a; if(N > 0){ a = A(N); } else{ a = A(0); } } component main = B(1); If the instruction a = A(0); is replaced with a = C(0) , the compilation fails and the next error message is shown: \"Assignee and assigned types do not match\" . We can define arrays of components following the same restrictions on the size given before. Moreover, initialization in the definition of arrays of components is not allowed, and instantiation can only be made component by component, accessing the positions of the array. All components in the array have to be instances of the same template as it can be seen in the next example. template MultiAND(n) { signal input in[n]; signal output out; component and; component ands[2]; var i; if (n==1) { out <== in[0]; } else if (n==2) { and = AND(); and.a <== in[0]; and.b <== in[1]; out <== and.out; } else { and = AND(); var n1 = n\\2; var n2 = n-n\\2; ands[0] = MultiAND(n1); ands[1] = MultiAND(n2); for (i=0; i<n1; i++) ands[0].in[i] <== in[i]; for (i=0; i<n2; i++) ands[1].in[i] <== in[n1+i]; and.a <== ands[0].out; and.b <== ands[1].out; out <== and.out; } } When components are independent (the inputs do not depend on each others\u2019 outputs), the computation of these parts can be done in parallel using the tag parallel , like shown in the next line. template parallel NameTemplate(...){...} If this tag is used, the resulting C++ file will contain the parallelized code to compute the witness. Parallelization becomes particularly relevant when dealing with large circuits. Custom templates Since version 2.0.6, the language allows the definition of a new type of templates, custom templates. This new construction works similarly to standard templates: they are declared analogously, just adding the keyword custom in its declaration after template ; and are instantiated in the exact same way. That is, a custom template Example is defined and then instantiated as follows: pragma circom 2.0.6; // note that custom templates are only allowed since version 2.0.6 pragma custom_templates; template custom Example() { // custom template's code } template UsingExample() { component example = Example(); // instantiation of the custom template } However, the way in which their computation is encoded is different from the one for standard templates. Instead of producing r1cs constraints, the usage of each defined custom template will be treated in a later stage by snarkjs to generate and validate the zk proof, in this case using the PLONK scheme (and using the custom template's definitions as PLONK's custom gates, see here how). Information about the definition and usages of custom templates will be exported in the .r1cs file (see here sections 4 and 5). This means that custom templates cannot introduce any constraint inside their body, nor declare any subcomponent.","title":"Templates & Components"},{"location":"circom-language/templates-and-components/#templates-components","text":"","title":"Templates &amp; Components"},{"location":"circom-language/templates-and-components/#templates","text":"The mechanism to create generic circuits in Circom is the so-called templates. They are normally parametric on some values that must be instantiated when the template is used. The instantiation of a template is a new circuit object, which can be used to compose other circuits, so as part of larger circuits. Since templates define circuits by instantiation, they have their own signals \\(input, output, etc\\) . template tempid ( param_1, ... , param_n ) { signal input a; signal output b; ..... } Templates cannot include local functions or template definitions. Assigning a value to an input signal inside the same template where it has been defined also generates the error \"Exception caused by invalid assignment\" as can be seen in the next example. pragma circom 2.0.0; template wrong (N) { signal input a; signal output b; a <== N; } component main = wrong(1); The instantiation of a template is made using the keyword component and by providing the necessary parameters. component c = tempid(v1,...,vn); The values of the parameters should be known constants at compile time. The next code produces this compilation error message: \"Every component instantiation must be resolved during the constraint generation phase\". pragma circom 2.0.0; template A(N1,N2){ signal input in; signal output out; out <== N1 * in * N2; } template wrong (N) { signal input a; signal output b; component c = A(a,N); } component main {public [a]} = wrong(1); Regarding the signals defined in the template that will be part of the component, the following compiler messages will be generated if we use the option --inspect to compile the code: If a signal is not used in any constraint, a warning message will be generated. Moreover, if it is an input signal x then the compiler would suggest adding a constraint of the form x * 0 === 0; pragma circom 2.0.0; template A(N){ signal input in; signal intermediate; signal output out; intermediate <== 1; out <== intermediate; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"In template \"A \\(1\\) \". Unconstrained signal. \"in\" = Maybe use: in*0 === 0\" If an intermediary signal is used only in one constraint, a hint message will be generated. pragma circom 2.0.0; template A(N){ signal input in; signal inter; inter <== 1; signal output out; out <== in; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"_In template \"A \\(1\\) \". One constraint intermediate: \"inter\" = Maybe use: inter*0 === 0\". If there is no output signal a warning message will be generated. pragma circom 2.0.0; template A(N){ signal input in; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"There is no output signal.\" .","title":"Templates"},{"location":"circom-language/templates-and-components/#components","text":"A component defines an arithmetic circuit and, as such, it receives N input signals and produces M output signals and K intermediate signals. Additionally, it can produce a set of constraints. In order to access the input or output signals of a component, we will use dot notation . No other signals are visible outside the component. c.a <== y*z-1; var x; x = c.b; The component instantiation will not be triggered until all its input signals are assigned to concrete values. Therefore the instantiation might be delayed and hence the component creation instruction does not imply the execution of the component object, but the creation of the instantiation process that will be completed when all the inputs are set. The output signals of a component can only be used when all inputs are set, otherwise a compiler error is generated. For instance, the following piece of code would result in an error: pragma circom 2.0.0; template Internal() { signal input in[2]; signal output out; out <== in[0]*in[1]; } template Main() { signal input in[2]; signal output out; component c = Internal (); c.in[0] <== in[0]; c.out ==> out; // c.in[1] is not assigned yet c.in[1] <== in[1]; // this line should be placed before calling c.out } component main = Main(); Components are immutable (like signals). A component can be declared first and initialized in a second step. If there are several initialization instructions (in different execution paths) they all need to be instantiations of the same template (maybe with different values for the parameters). template A(N){ signal input in; signal output out; out <== in; } template C(N){ signal output out; out <== N; } template B(N){ signal output out; component a; if(N > 0){ a = A(N); } else{ a = A(0); } } component main = B(1); If the instruction a = A(0); is replaced with a = C(0) , the compilation fails and the next error message is shown: \"Assignee and assigned types do not match\" . We can define arrays of components following the same restrictions on the size given before. Moreover, initialization in the definition of arrays of components is not allowed, and instantiation can only be made component by component, accessing the positions of the array. All components in the array have to be instances of the same template as it can be seen in the next example. template MultiAND(n) { signal input in[n]; signal output out; component and; component ands[2]; var i; if (n==1) { out <== in[0]; } else if (n==2) { and = AND(); and.a <== in[0]; and.b <== in[1]; out <== and.out; } else { and = AND(); var n1 = n\\2; var n2 = n-n\\2; ands[0] = MultiAND(n1); ands[1] = MultiAND(n2); for (i=0; i<n1; i++) ands[0].in[i] <== in[i]; for (i=0; i<n2; i++) ands[1].in[i] <== in[n1+i]; and.a <== ands[0].out; and.b <== ands[1].out; out <== and.out; } } When components are independent (the inputs do not depend on each others\u2019 outputs), the computation of these parts can be done in parallel using the tag parallel , like shown in the next line. template parallel NameTemplate(...){...} If this tag is used, the resulting C++ file will contain the parallelized code to compute the witness. Parallelization becomes particularly relevant when dealing with large circuits.","title":"Components"},{"location":"circom-language/templates-and-components/#custom-templates","text":"Since version 2.0.6, the language allows the definition of a new type of templates, custom templates. This new construction works similarly to standard templates: they are declared analogously, just adding the keyword custom in its declaration after template ; and are instantiated in the exact same way. That is, a custom template Example is defined and then instantiated as follows: pragma circom 2.0.6; // note that custom templates are only allowed since version 2.0.6 pragma custom_templates; template custom Example() { // custom template's code } template UsingExample() { component example = Example(); // instantiation of the custom template } However, the way in which their computation is encoded is different from the one for standard templates. Instead of producing r1cs constraints, the usage of each defined custom template will be treated in a later stage by snarkjs to generate and validate the zk proof, in this case using the PLONK scheme (and using the custom template's definitions as PLONK's custom gates, see here how). Information about the definition and usages of custom templates will be exported in the .r1cs file (see here sections 4 and 5). This means that custom templates cannot introduce any constraint inside their body, nor declare any subcomponent.","title":"Custom templates"},{"location":"circom-language/the-main-component/","text":"The Main Component In order to start the execution, an initial component has to be given. By default, the name of this component is \u201cmain\u201d, and hence the component main needs to be instantiated with some template. This is a special initial component needed to create a circuit and it defines the global input and output signals of a circuit. For this reason, compared to the other components, it has a special attribute: the list of public input signals. The syntax of the creation of the main component is: component main {public [signal_list]} = tempid(v1,...,vn); where {public [signal_list]} is optional. Any input signal of the template that is not included in the list is considered private. pragma circom 2.0.0; template A(){ signal input in1; signal input in2; signal output out; out <== in1 * in2; } component main {public [in1]}= A(); In this example, we have two input signals in1 and in2 . Let us notice that in1 has been declared as a public signal for the circuit, whereas in2 is considered a private signal since it does not appear in the list. Finally, output signals are always considered public signals. Only one main component can be defined, not only in the file being compiled but also in any other circom file included in the program. Otherwise, the compilation fails and the next message is shown: \"Multiple main components in the project structure\"","title":"The main Component"},{"location":"circom-language/the-main-component/#the-main-component","text":"In order to start the execution, an initial component has to be given. By default, the name of this component is \u201cmain\u201d, and hence the component main needs to be instantiated with some template. This is a special initial component needed to create a circuit and it defines the global input and output signals of a circuit. For this reason, compared to the other components, it has a special attribute: the list of public input signals. The syntax of the creation of the main component is: component main {public [signal_list]} = tempid(v1,...,vn); where {public [signal_list]} is optional. Any input signal of the template that is not included in the list is considered private. pragma circom 2.0.0; template A(){ signal input in1; signal input in2; signal output out; out <== in1 * in2; } component main {public [in1]}= A(); In this example, we have two input signals in1 and in2 . Let us notice that in1 has been declared as a public signal for the circuit, whereas in2 is considered a private signal since it does not appear in the list. Finally, output signals are always considered public signals. Only one main component can be defined, not only in the file being compiled but also in any other circom file included in the program. Otherwise, the compilation fails and the next message is shown: \"Multiple main components in the project structure\"","title":"The Main Component"},{"location":"circom-language/variables-and-mutability/","text":"Variables & Mutability Variables are identifiers that hold non-signal data and are mutable. Variables are declared using the keyword var as in: var x; They hold either numerical values of the field or arithmetic expressions when they are used to build constraints (see Constraint Generation ). They can be named using a variable identifier or can be stored in arrays. Variable assignment is made using the equal symbol = . Declarations may also include an initialization, as in the following examples: var x; x = 234556; var y = 0; var z[3] = [1,2,3] An assignment is a statement and does not return any value, hence it cannot be part of an expression, which avoids misleading uses of = . Any use of = inside an expression will lead to a compilation error. The two examples below would result in compilation errors: a = (b = 3) + 2; var x; if (x = 3) { var y = 0; }","title":"Variables & Mutability"},{"location":"circom-language/variables-and-mutability/#variables-mutability","text":"Variables are identifiers that hold non-signal data and are mutable. Variables are declared using the keyword var as in: var x; They hold either numerical values of the field or arithmetic expressions when they are used to build constraints (see Constraint Generation ). They can be named using a variable identifier or can be stored in arrays. Variable assignment is made using the equal symbol = . Declarations may also include an initialization, as in the following examples: var x; x = 234556; var y = 0; var z[3] = [1,2,3] An assignment is a statement and does not return any value, hence it cannot be part of an expression, which avoids misleading uses of = . Any use of = inside an expression will lead to a compilation error. The two examples below would result in compilation errors: a = (b = 3) + 2; var x; if (x = 3) { var y = 0; }","title":"Variables &amp; Mutability"},{"location":"circom-language/circom-insight/circom-library/","text":"circom Library \ud83d\udc49 CircomLib \ud83d\udc48","title":"Circom Library"},{"location":"circom-language/circom-insight/circom-library/#circom-library","text":"","title":"circom Library"},{"location":"circom-language/circom-insight/circom-library/#circomlib","text":"","title":"\ud83d\udc49 CircomLib \ud83d\udc48"},{"location":"circom-language/circom-insight/circom-phases/","text":"circom Compiler circom has two compilation phases: The construction phase, where the constraints are generated. The code generation phase, where the code to compute the witness is generated.","title":"Compiler Phases"},{"location":"circom-language/circom-insight/circom-phases/#circom-compiler","text":"circom has two compilation phases: The construction phase, where the constraints are generated. The code generation phase, where the code to compute the witness is generated.","title":"circom Compiler"},{"location":"circom-language/circom-insight/compiler-messages/","text":"Compiler Messages The compiler messages are basically of three kinds: hints, warnings and errors. A hint This message means that it is allowed but uncommon, and hence it is better to check if it was done on purpose. A warning This message means that it is allowed but should not happen in general. For instance, if a signal is not used in any constraint, a warning message will be generated (when compiling the program with the --inspect option). Moreover, if it is an input signal x, then the compiler would suggest adding a constraint of the form x * 0 === 0; pragma circom 2.0.0; template A(N){ signal input in; signal intermediate; signal output out; intermediate <== 1; out <== intermediate; } component main {public [in]} = A(1); An error This message means that it is not allowed and the compilation of the program fails. For instance, one of the most common errors we can make when starting to program in circom is trying to assign a value to a signal using = . pragma circom 2.0.0; template A(){ signal in; in = 1; } component main = A(); The compilation fails and the next error is received: \"Assignee and assigned types do not match operator.\"","title":"Compiler Messages"},{"location":"circom-language/circom-insight/compiler-messages/#compiler-messages","text":"The compiler messages are basically of three kinds: hints, warnings and errors.","title":"Compiler Messages"},{"location":"circom-language/circom-insight/compiler-messages/#a-hint","text":"This message means that it is allowed but uncommon, and hence it is better to check if it was done on purpose.","title":"A hint"},{"location":"circom-language/circom-insight/compiler-messages/#a-warning","text":"This message means that it is allowed but should not happen in general. For instance, if a signal is not used in any constraint, a warning message will be generated (when compiling the program with the --inspect option). Moreover, if it is an input signal x, then the compiler would suggest adding a constraint of the form x * 0 === 0; pragma circom 2.0.0; template A(N){ signal input in; signal intermediate; signal output out; intermediate <== 1; out <== intermediate; } component main {public [in]} = A(1);","title":"A warning"},{"location":"circom-language/circom-insight/compiler-messages/#an-error","text":"This message means that it is not allowed and the compilation of the program fails. For instance, one of the most common errors we can make when starting to program in circom is trying to assign a value to a signal using = . pragma circom 2.0.0; template A(){ signal in; in = 1; } component main = A(); The compilation fails and the next error is received: \"Assignee and assigned types do not match operator.\"","title":"An error"},{"location":"circom-language/circom-insight/unknowns/","text":"Unknowns As expressions accepted during constraint generation can at most be quadratic only, certain checks and constraints are imposed on the use of unknown values at compile. In circom, constant values and template parameters are always considered known, while signals are always considered unknown. Expressions depending only on knowns are considered knowns, while those depending on unknowns are considered unknowns. pragma circom 2.0.0; template A(n1, n2){ // known signal input in1; // unknown signal input in2; // unknown var x = 0; // known var y = n1; // known var z = in1; // unknown } component main = A(1, 2); In the code above, the template parameters n1 , n2 and the constant value 0 are considered known. Consequently, the variables x and y are also considered known. Meanwhile, the signals in1 , in2 are considered unknown. Consequently, the variable z is also considered unknown. Array A constraint with an array access must have a known accessing position. pragma circom 2.0.0; template A(n){ signal input in; signal output out; var array[n]; out <== array[in]; // Error: Non-quadratic constraint was detected statically, using unknown index will cause the constraint to be non-quadratic } component main = A(10); In the code above, an array is defined with a known size of value n (as template parameters are always considered known), while a constraint is set to be dependent on the array element at an unknown position in (as signals are always considered unknown). An array must also be defined with a known size. pragma circom 2.0.0; template A(){ signal input in; var array[in]; // Error: The length of every array must known during the constraint generation phase } component main = A(); In the code above, an array is defined with an unknown size of value in (as signals are always considered unknown). Control Flow A constraint generated in a control flow must have a known condition. Take an if-then statement as an example: pragma circom 2.0.0; template A(){ signal input in; signal output out; if (in < 0){ // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase out <== 0; } } component main = A(); In the code above, a constraint is defined in an if-then statement with a comparitive condition involving an unknown value in (as signals are always considered unknown). Similarly, using a for-loop as an example: pragma circom 2.0.0; template A(){ signal input in; signal output out; for (var i = 0; i < in; i++){ // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase out <== i; } } component main = A(); In the code above, a constraint is defined in a for-loop with a counting condition to an unknown value in (as signals are always considered unknown). For additional details, see Control Flow .","title":"Unknowns"},{"location":"circom-language/circom-insight/unknowns/#unknowns","text":"As expressions accepted during constraint generation can at most be quadratic only, certain checks and constraints are imposed on the use of unknown values at compile. In circom, constant values and template parameters are always considered known, while signals are always considered unknown. Expressions depending only on knowns are considered knowns, while those depending on unknowns are considered unknowns. pragma circom 2.0.0; template A(n1, n2){ // known signal input in1; // unknown signal input in2; // unknown var x = 0; // known var y = n1; // known var z = in1; // unknown } component main = A(1, 2); In the code above, the template parameters n1 , n2 and the constant value 0 are considered known. Consequently, the variables x and y are also considered known. Meanwhile, the signals in1 , in2 are considered unknown. Consequently, the variable z is also considered unknown.","title":"Unknowns"},{"location":"circom-language/circom-insight/unknowns/#array","text":"A constraint with an array access must have a known accessing position. pragma circom 2.0.0; template A(n){ signal input in; signal output out; var array[n]; out <== array[in]; // Error: Non-quadratic constraint was detected statically, using unknown index will cause the constraint to be non-quadratic } component main = A(10); In the code above, an array is defined with a known size of value n (as template parameters are always considered known), while a constraint is set to be dependent on the array element at an unknown position in (as signals are always considered unknown). An array must also be defined with a known size. pragma circom 2.0.0; template A(){ signal input in; var array[in]; // Error: The length of every array must known during the constraint generation phase } component main = A(); In the code above, an array is defined with an unknown size of value in (as signals are always considered unknown).","title":"Array"},{"location":"circom-language/circom-insight/unknowns/#control-flow","text":"A constraint generated in a control flow must have a known condition. Take an if-then statement as an example: pragma circom 2.0.0; template A(){ signal input in; signal output out; if (in < 0){ // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase out <== 0; } } component main = A(); In the code above, a constraint is defined in an if-then statement with a comparitive condition involving an unknown value in (as signals are always considered unknown). Similarly, using a for-loop as an example: pragma circom 2.0.0; template A(){ signal input in; signal output out; for (var i = 0; i < in; i++){ // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase out <== i; } } component main = A(); In the code above, a constraint is defined in a for-loop with a counting condition to an unknown value in (as signals are always considered unknown). For additional details, see Control Flow .","title":"Control Flow"},{"location":"circom-language/code-quality/code-assertion/","text":"Code Assertion assert(bool_expression); This statement introduces conditions to be checked at execution time. If the condition fails, the witness generation is interrupted and the error is reported. template Translate(n) { assert(n<=254); \u2026.. } Recall that, when a constraint is introduced with ===, then an assert is automatically added in the witness generation code.","title":"Code Assertion"},{"location":"circom-language/code-quality/code-assertion/#code-assertion","text":"assert(bool_expression); This statement introduces conditions to be checked at execution time. If the condition fails, the witness generation is interrupted and the error is reported. template Translate(n) { assert(n<=254); \u2026.. } Recall that, when a constraint is introduced with ===, then an assert is automatically added in the witness generation code.","title":"Code Assertion"},{"location":"circom-language/code-quality/debugging-operations/","text":"Debugging Operations In circom there is an operation that can be used while developing circuits to help the programmer debug (note that there are no input/output operations on the standard input/output channels). To this end, the operation log has as parameter a non-conditional expression (i.e., not including the ? ;_ operator). The execution of this instruction prints the result of the evaluation of the expression in the standard error stream. As examples consider: log(135); log(c.b); log(x==y); Since circom 2.0.6, operation log admits a list of non-conditional expressions and also strings written in the standard way. For instance: log(\"The expected result is \",135,\" but the value of a is\",a); Finally, this operations admits an empty list of expressions which is equivalent to print an end-of-line. The next two instructions are equivalent: log(\"\"); log();","title":"Debugging Operations"},{"location":"circom-language/code-quality/debugging-operations/#debugging-operations","text":"In circom there is an operation that can be used while developing circuits to help the programmer debug (note that there are no input/output operations on the standard input/output channels). To this end, the operation log has as parameter a non-conditional expression (i.e., not including the ? ;_ operator). The execution of this instruction prints the result of the evaluation of the expression in the standard error stream. As examples consider: log(135); log(c.b); log(x==y); Since circom 2.0.6, operation log admits a list of non-conditional expressions and also strings written in the standard way. For instance: log(\"The expected result is \",135,\" but the value of a is\",a); Finally, this operations admits an empty list of expressions which is equivalent to print an end-of-line. The next two instructions are equivalent: log(\"\"); log();","title":"Debugging Operations"},{"location":"downloads/downloads/","text":"circom Linux binary circom macOS binary circom Windows binary","title":"Downloads"},{"location":"getting-started/compiling-circuits/","text":"Compiling our circuit Once you have the compiler installed you can see the available options as follows: circom --help Circom Compiler 2.0 IDEN3 Compiler for the Circom programming language USAGE: circom [FLAGS] [OPTIONS] [input] FLAGS: -h, --help Prints help information --inspect Does an additional check over the constraints produced --O0 No simplification is applied -c, --c Compiles the circuit to c --json outputs the constraints in json format --r1cs outputs the constraints in r1cs format --sym outputs witness in sym format --wasm Compiles the circuit to wasm --wat Compiles the circuit to wat --O1 Only applies var to var and var to constant simplification -V, --version Prints version information OPTIONS: --O2 <full_simplification> Full constraint simplification [default: full] -o, --output <output> Path to the directory where the output will be written [default: .] ARGS: <input> Path to a circuit with a main component [default: ./circuit.circom] We created a template called Multiplier2 in Writing our first circuit . However, to actually create a circuit, we have to create an instance of this template. To do so, create a file with the following content: pragma circom 2.0.0; template Multiplier2() { signal input a; signal input b; signal output c; c <== a*b; } component main = Multiplier2(); After we write our arithmetic circuit using circom , we should save it in a file with the .circom extension. Remember that you can create your own circuits or use the templates from our library of circuits circomlib . In our example, we create a file called multiplier2.circom . Now is time to compile the circuit to get a system of arithmetic equations representing it. As a result of the compilation we will also obtain programs to compute the witness. We can compile the circuit with the following command: circom multiplier2.circom --r1cs --wasm --sym --c With these options we generate three types of files: --r1cs : it generates the file multiplier2.r1cs that contains the R1CS constraint system of the circuit in binary format. --wasm : it generates the directory multiplier2_js that contains the Wasm code (multiplier2.wasm) and other files needed to generate the witness . --sym : it generates the file multiplier2.sym , a symbols file required for debugging or for printing the constraint system in an annotated mode. --c : it generates the directory multiplier2_cpp that contains several files (multiplier2.cpp, multiplier2.dat, and other common files for every compiled program like main.cpp, MakeFile, etc) needed to compile the C code to generate the witness. We can use the option -o to specify the directory where these files are created.","title":"Compiling circuits"},{"location":"getting-started/compiling-circuits/#compiling-our-circuit","text":"Once you have the compiler installed you can see the available options as follows: circom --help Circom Compiler 2.0 IDEN3 Compiler for the Circom programming language USAGE: circom [FLAGS] [OPTIONS] [input] FLAGS: -h, --help Prints help information --inspect Does an additional check over the constraints produced --O0 No simplification is applied -c, --c Compiles the circuit to c --json outputs the constraints in json format --r1cs outputs the constraints in r1cs format --sym outputs witness in sym format --wasm Compiles the circuit to wasm --wat Compiles the circuit to wat --O1 Only applies var to var and var to constant simplification -V, --version Prints version information OPTIONS: --O2 <full_simplification> Full constraint simplification [default: full] -o, --output <output> Path to the directory where the output will be written [default: .] ARGS: <input> Path to a circuit with a main component [default: ./circuit.circom] We created a template called Multiplier2 in Writing our first circuit . However, to actually create a circuit, we have to create an instance of this template. To do so, create a file with the following content: pragma circom 2.0.0; template Multiplier2() { signal input a; signal input b; signal output c; c <== a*b; } component main = Multiplier2(); After we write our arithmetic circuit using circom , we should save it in a file with the .circom extension. Remember that you can create your own circuits or use the templates from our library of circuits circomlib . In our example, we create a file called multiplier2.circom . Now is time to compile the circuit to get a system of arithmetic equations representing it. As a result of the compilation we will also obtain programs to compute the witness. We can compile the circuit with the following command: circom multiplier2.circom --r1cs --wasm --sym --c With these options we generate three types of files: --r1cs : it generates the file multiplier2.r1cs that contains the R1CS constraint system of the circuit in binary format. --wasm : it generates the directory multiplier2_js that contains the Wasm code (multiplier2.wasm) and other files needed to generate the witness . --sym : it generates the file multiplier2.sym , a symbols file required for debugging or for printing the constraint system in an annotated mode. --c : it generates the directory multiplier2_cpp that contains several files (multiplier2.cpp, multiplier2.dat, and other common files for every compiled program like main.cpp, MakeFile, etc) needed to compile the C code to generate the witness. We can use the option -o to specify the directory where these files are created.","title":"Compiling our circuit"},{"location":"getting-started/computing-the-witness/","text":"Computing our witness What is a witness? Before creating the proof, we need to calculate all the signals of the circuit that match all the constraints of the circuit. For that, we will use the Wasm module generated by circom that helps to do this job. It can also be done with the C++ code in a similar way (see below). Let us start with the Wasm code. Using the generated Wasm binary and three JavaScript files, we simply need to provide a file with the inputs and the module will execute the circuit and calculate all the intermediate signals and the output. The set of inputs, intermediate signals and output is called witness . In our case, we want to prove that we are able to factor the number 33. So, we assign a = 3 and b = 11 . Note that we could assign the number 1 to one of the inputs and the number 33 to the other. So, our proof does not really show that we are able to factor the number 33. We need to create a file named input.json containing the inputs written in the standard json format. {\"a\": 3, \"b\": 11} Now, we calculate the witness and generate a binary file witness.wtns containing it in a format accepted by snarkjs . After calling the circom compiler with the flag --wasm and the circuit multiplier2.circom we can find a multiplier2_js folder that contains the Wasm code in multiplier2.wasm and all the needed JavaScript files. Computing the witness with WebAssembly Enter in the directory multiplier2_js , add the input in a file input.json and execute: node generate_witness.js multiplier2.wasm input.json witness.wtns Computing the witness with C++ As a faster alternative, we can use the C++ directory to compute the witness using the previous file input.json . This directory is created when using the circom compiler with the flag --c . In our example, the compiler creates a multiplier2_cpp folder that contains all the C++ code needed to compute the witness and a Makefile to easily generate the corresponding executable program. To do so, enter the directory multiplier2_cpp and execute: make The previous command creates an executable called multiplier2 . Note. To compile the C++ source, we rely on some libraries that you need to have installed in your system. In particular, we use nlohmann-json3-dev , libgmp-dev and nasm . After the executable is created, we execute it indicating the input file and the name for the witness file: ./multiplier2 input.json witness.wtns The Witness file The two programs will generate the same \u1e81itness.wtns file. This file is encoded in a binary format compatible with snarkjs , which is the tool that we use to create the actual proofs. Note. For big circuits, the C++ witness calculator is significantly faster than the WASM calculator.","title":"Computing the witness"},{"location":"getting-started/computing-the-witness/#computing-our-witness","text":"","title":"Computing our witness"},{"location":"getting-started/computing-the-witness/#what-is-a-witness","text":"Before creating the proof, we need to calculate all the signals of the circuit that match all the constraints of the circuit. For that, we will use the Wasm module generated by circom that helps to do this job. It can also be done with the C++ code in a similar way (see below). Let us start with the Wasm code. Using the generated Wasm binary and three JavaScript files, we simply need to provide a file with the inputs and the module will execute the circuit and calculate all the intermediate signals and the output. The set of inputs, intermediate signals and output is called witness . In our case, we want to prove that we are able to factor the number 33. So, we assign a = 3 and b = 11 . Note that we could assign the number 1 to one of the inputs and the number 33 to the other. So, our proof does not really show that we are able to factor the number 33. We need to create a file named input.json containing the inputs written in the standard json format. {\"a\": 3, \"b\": 11} Now, we calculate the witness and generate a binary file witness.wtns containing it in a format accepted by snarkjs . After calling the circom compiler with the flag --wasm and the circuit multiplier2.circom we can find a multiplier2_js folder that contains the Wasm code in multiplier2.wasm and all the needed JavaScript files.","title":"What is a witness?"},{"location":"getting-started/computing-the-witness/#computing-the-witness-with-webassembly","text":"Enter in the directory multiplier2_js , add the input in a file input.json and execute: node generate_witness.js multiplier2.wasm input.json witness.wtns","title":"Computing the witness with WebAssembly "},{"location":"getting-started/computing-the-witness/#computing-the-witness-with-c","text":"As a faster alternative, we can use the C++ directory to compute the witness using the previous file input.json . This directory is created when using the circom compiler with the flag --c . In our example, the compiler creates a multiplier2_cpp folder that contains all the C++ code needed to compute the witness and a Makefile to easily generate the corresponding executable program. To do so, enter the directory multiplier2_cpp and execute: make The previous command creates an executable called multiplier2 . Note. To compile the C++ source, we rely on some libraries that you need to have installed in your system. In particular, we use nlohmann-json3-dev , libgmp-dev and nasm . After the executable is created, we execute it indicating the input file and the name for the witness file: ./multiplier2 input.json witness.wtns","title":"Computing the witness with C++  "},{"location":"getting-started/computing-the-witness/#the-witness-file","text":"The two programs will generate the same \u1e81itness.wtns file. This file is encoded in a binary format compatible with snarkjs , which is the tool that we use to create the actual proofs. Note. For big circuits, the C++ witness calculator is significantly faster than the WASM calculator.","title":"The Witness file"},{"location":"getting-started/installation/","text":"Installing the circom ecosystem \u26a0 Important deprecation note The old circom compiler written in Javascript will be frozen, but it can still be downloaded from the old circom repository . Installing dependencies You need several dependencies in your system to run circom and its associated tools. The core tool is the circom compiler which is written in Rust. To have Rust available in your system, you can install rustup . If you\u2019re using Linux or macOS, open a terminal and enter the following command: curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh We also distribute a series of npm packages so Node.js and some package manager like npm or yarn should be available in your system. Recent versions of Node.js include big integer support and web assembly compilers that help run code faster, so to get a better performance, install version 10 or higher. Installing circom To install from our sources, clone the circom repository: git clone https://github.com/iden3/circom.git Enter the circom directory and use the cargo build to compile: cargo build --release The installation takes around 3 minutes to be completed. When the command successfully finishes, it generates the circom binary in the directory target/release . You can install this binary as follows: cargo install --path circom The previous command will install the circom binary in the directory $HOME/.cargo/bin . Now, you should be able to see all the options of the executable by using the help flag: circom --help Circom Compiler 2.0.0 IDEN3 Compiler for the Circom programming language USAGE: circom [FLAGS] [OPTIONS] [input] FLAGS: -h, --help Prints help information --inspect Does an additional check over the constraints produced --O0 No simplification is applied -c, --c Compiles the circuit to c --json outputs the constraints in json format --r1cs outputs the constraints in r1cs format --sym outputs witness in sym format --wasm Compiles the circuit to wasm --wat Compiles the circuit to wat --O1 Only applies var to var and var to constant simplification -V, --version Prints version information OPTIONS: --O2 <full_simplification> Full constraint simplification [default: full] -o, --output <output> Path to the directory where the output will be written [default: .] ARGS: <input> Path to a circuit with a main component [default: ./circuit.circom] Installing snarkjs snarkjs is a npm package that contains code to generate and validate ZK proofs from the artifacts produced by circom . You can install snarkjs with the following command: npm install -g snarkjs","title":"Installation"},{"location":"getting-started/installation/#installing-the-circom-ecosystem","text":"","title":"Installing the circom ecosystem"},{"location":"getting-started/installation/#important-deprecation-note","text":"The old circom compiler written in Javascript will be frozen, but it can still be downloaded from the old circom repository .","title":"&#9888; Important deprecation note"},{"location":"getting-started/installation/#installing-dependencies","text":"You need several dependencies in your system to run circom and its associated tools. The core tool is the circom compiler which is written in Rust. To have Rust available in your system, you can install rustup . If you\u2019re using Linux or macOS, open a terminal and enter the following command: curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh We also distribute a series of npm packages so Node.js and some package manager like npm or yarn should be available in your system. Recent versions of Node.js include big integer support and web assembly compilers that help run code faster, so to get a better performance, install version 10 or higher.","title":"Installing dependencies"},{"location":"getting-started/installation/#installing-circom","text":"To install from our sources, clone the circom repository: git clone https://github.com/iden3/circom.git Enter the circom directory and use the cargo build to compile: cargo build --release The installation takes around 3 minutes to be completed. When the command successfully finishes, it generates the circom binary in the directory target/release . You can install this binary as follows: cargo install --path circom The previous command will install the circom binary in the directory $HOME/.cargo/bin . Now, you should be able to see all the options of the executable by using the help flag: circom --help Circom Compiler 2.0.0 IDEN3 Compiler for the Circom programming language USAGE: circom [FLAGS] [OPTIONS] [input] FLAGS: -h, --help Prints help information --inspect Does an additional check over the constraints produced --O0 No simplification is applied -c, --c Compiles the circuit to c --json outputs the constraints in json format --r1cs outputs the constraints in r1cs format --sym outputs witness in sym format --wasm Compiles the circuit to wasm --wat Compiles the circuit to wat --O1 Only applies var to var and var to constant simplification -V, --version Prints version information OPTIONS: --O2 <full_simplification> Full constraint simplification [default: full] -o, --output <output> Path to the directory where the output will be written [default: .] ARGS: <input> Path to a circuit with a main component [default: ./circuit.circom]","title":"Installing circom"},{"location":"getting-started/installation/#installing-snarkjs","text":"snarkjs is a npm package that contains code to generate and validate ZK proofs from the artifacts produced by circom . You can install snarkjs with the following command: npm install -g snarkjs","title":"Installing snarkjs "},{"location":"getting-started/proving-circuits/","text":"Proving circuits After compiling the circuit and running the witness calculator with an appropriate input, we will have a file with extension .wtns that contains all the computed signals and, a file with extension .r1cs that contains the constraints describing the circuit. Both files will be used to create our proof. Now, we will use the snarkjs tool to generate and validate a proof for our input. In particular, using the multiplier2, we will prove that we are able to provide the two factors of the number 33 . That is, we will show that we know two integers a and b such that when we multiply them, it results in the number 33. We are going to use the Groth16 zk-SNARK protocol. To use this protocol, you will need to generate a trusted setup . Groth16 requires a per circuit trusted setup . In more detail, the trusted setup consists of 2 parts: The powers of tau, which is independent of the circuit. The phase 2, which depends on the circuit. Next, we provide a very basic ceremony for creating the trusted setup and we also provide the basic commands to create and verify Groth16 proofs. Review the related Background section and check the snarkjs tutorial for further information. Powers of Tau First, we start a new \"powers of tau\" ceremony: snarkjs powersoftau new bn128 12 pot12_0000.ptau -v Then, we contribute to the ceremony: snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\"First contribution\" -v Now, we have the contributions to the powers of tau in the file pot12_0001.ptau and we can proceed with the Phase 2. Phase 2 The phase 2 is circuit-specific . Execute the following command to start the generation of this phase: snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v Next, we generate a .zkey file that will contain the proving and verification keys together with all phase 2 contributions. Execute the following command to start a new zkey: snarkjs groth16 setup multiplier2.r1cs pot12_final.ptau multiplier2_0000.zkey Contribute to the phase 2 of the ceremony: snarkjs zkey contribute multiplier2_0000.zkey multiplier2_0001.zkey --name=\"1st Contributor Name\" -v Export the verification key: snarkjs zkey export verificationkey multiplier2_0001.zkey verification_key.json Generating a Proof Once the witness is computed and the trusted setup is already executed, we can generate a zk-proof associated to the circuit and the witness: snarkjs groth16 prove multiplier2_0001.zkey witness.wtns proof.json public.json This command generates a Groth16 proof and outputs two files: proof.json : it contains the proof. public.json : it contains the values of the public inputs and outputs. Verifying a Proof To verify the proof , execute the following command: snarkjs groth16 verify verification_key.json public.json proof.json The command uses the files verification_key.json we exported earlier, proof.json and public.json to check if the proof is valid. If the proof is valid, the command outputs an OK . A valid proof not only proves that we know a set of signals that satisfy the circuit, but also that the public inputs and outputs that we use match the ones described in the public.json file. Verifying from a Smart Contract \u200b\ud83d\udc49 It is also possible to generate a Solidity verifier that allows verifying proofs on Ethereum blockchain . First, we need to generate the Solidity code using the command: snarkjs zkey export solidityverifier multiplier2_0001.zkey verifier.sol This command takes validation key multiplier2_0001.zkey and outputs Solidity code in a file named verifier.sol . You can take the code from this file and cut and paste it in Remix. You will see that the code contains two contracts: Pairing and Verifier . You only need to deploy the Verifier contract. You may want to use first a testnet like Rinkeby, Kovan or Ropsten. You can also use the JavaScript VM, but in some browsers the verification takes long and the page may freeze. The Verifier has a view function called verifyProof that returns TRUE if and only if the proof and the inputs are valid. To facilitate the call, you can use snarkJS to generate the parameters of the call by typing: snarkjs generatecall Cut and paste the output of the command to the parameters field of the verifyProof method in Remix. If everything works fine, this method should return TRUE . You can try to change just a single bit of the parameters, and you will see that the result is verifiable FALSE .","title":"Proving circuits with ZK"},{"location":"getting-started/proving-circuits/#proving-circuits","text":"After compiling the circuit and running the witness calculator with an appropriate input, we will have a file with extension .wtns that contains all the computed signals and, a file with extension .r1cs that contains the constraints describing the circuit. Both files will be used to create our proof. Now, we will use the snarkjs tool to generate and validate a proof for our input. In particular, using the multiplier2, we will prove that we are able to provide the two factors of the number 33 . That is, we will show that we know two integers a and b such that when we multiply them, it results in the number 33. We are going to use the Groth16 zk-SNARK protocol. To use this protocol, you will need to generate a trusted setup . Groth16 requires a per circuit trusted setup . In more detail, the trusted setup consists of 2 parts: The powers of tau, which is independent of the circuit. The phase 2, which depends on the circuit. Next, we provide a very basic ceremony for creating the trusted setup and we also provide the basic commands to create and verify Groth16 proofs. Review the related Background section and check the snarkjs tutorial for further information.","title":"Proving circuits"},{"location":"getting-started/proving-circuits/#powers-of-tau","text":"First, we start a new \"powers of tau\" ceremony: snarkjs powersoftau new bn128 12 pot12_0000.ptau -v Then, we contribute to the ceremony: snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\"First contribution\" -v Now, we have the contributions to the powers of tau in the file pot12_0001.ptau and we can proceed with the Phase 2.","title":"Powers of Tau "},{"location":"getting-started/proving-circuits/#phase-2","text":"The phase 2 is circuit-specific . Execute the following command to start the generation of this phase: snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v Next, we generate a .zkey file that will contain the proving and verification keys together with all phase 2 contributions. Execute the following command to start a new zkey: snarkjs groth16 setup multiplier2.r1cs pot12_final.ptau multiplier2_0000.zkey Contribute to the phase 2 of the ceremony: snarkjs zkey contribute multiplier2_0000.zkey multiplier2_0001.zkey --name=\"1st Contributor Name\" -v Export the verification key: snarkjs zkey export verificationkey multiplier2_0001.zkey verification_key.json","title":"Phase 2 "},{"location":"getting-started/proving-circuits/#generating-a-proof","text":"Once the witness is computed and the trusted setup is already executed, we can generate a zk-proof associated to the circuit and the witness: snarkjs groth16 prove multiplier2_0001.zkey witness.wtns proof.json public.json This command generates a Groth16 proof and outputs two files: proof.json : it contains the proof. public.json : it contains the values of the public inputs and outputs.","title":"Generating a Proof"},{"location":"getting-started/proving-circuits/#verifying-a-proof","text":"To verify the proof , execute the following command: snarkjs groth16 verify verification_key.json public.json proof.json The command uses the files verification_key.json we exported earlier, proof.json and public.json to check if the proof is valid. If the proof is valid, the command outputs an OK . A valid proof not only proves that we know a set of signals that satisfy the circuit, but also that the public inputs and outputs that we use match the ones described in the public.json file.","title":"Verifying a Proof"},{"location":"getting-started/proving-circuits/#verifying-from-a-smart-contract","text":"\u200b\ud83d\udc49 It is also possible to generate a Solidity verifier that allows verifying proofs on Ethereum blockchain . First, we need to generate the Solidity code using the command: snarkjs zkey export solidityverifier multiplier2_0001.zkey verifier.sol This command takes validation key multiplier2_0001.zkey and outputs Solidity code in a file named verifier.sol . You can take the code from this file and cut and paste it in Remix. You will see that the code contains two contracts: Pairing and Verifier . You only need to deploy the Verifier contract. You may want to use first a testnet like Rinkeby, Kovan or Ropsten. You can also use the JavaScript VM, but in some browsers the verification takes long and the page may freeze. The Verifier has a view function called verifyProof that returns TRUE if and only if the proof and the inputs are valid. To facilitate the call, you can use snarkJS to generate the parameters of the call by typing: snarkjs generatecall Cut and paste the output of the command to the parameters field of the verifyProof method in Remix. If everything works fine, this method should return TRUE . You can try to change just a single bit of the parameters, and you will see that the result is verifiable FALSE .","title":"Verifying from a Smart Contract"},{"location":"getting-started/testing-circuits/","text":"Testing circuits Writing a test Run our tests","title":"Testing circuits"},{"location":"getting-started/testing-circuits/#testing-circuits","text":"","title":"Testing circuits"},{"location":"getting-started/testing-circuits/#writing-a-test","text":"","title":"Writing a test"},{"location":"getting-started/testing-circuits/#run-our-tests","text":"","title":"Run our tests"},{"location":"getting-started/writing-circuits/","text":"Writing circuits circom allows programmers to define the constraints that define the arithmetic circuit. All constraints must be of the form A*B + C = 0, where A, B and C are linear combinations of signals. More details about these equations can be found here . The arithmetic circuits built using circom operate on signals. Let us define our first circuit that simply multiplies two input signals and produces an output signal. pragma circom 2.0.0; /*This circuit template checks that c is the multiplication of a and b.*/ template Multiplier2 () { // Declaration of signals. signal input a; signal input b; signal output c; // Constraints. c <== a * b; } First, the pragma instruction is used to specify the compiler version. This is to ensure that the circuit is compatible with the compiler version indicated after the pragma instruction. Otherwise, the compiler will throw a warning. Then, we use the reserved keyword template to define the shape of a new circuit, called Multiplier2 . Now, we have to define its signals . Signals can be named with an identifier, e.g., a, b, c. In this circuit, we have two input signals a, b and an output signal c . Finally, we use <== to set that the value of c is the result of multiplying the values of a and b . Equivalently, we could have also used the operator ==> , e.g., a * b ==> c . Let us notice that in each template, we first declare its signals, and after that, the associated constraints.","title":"Writing circuits"},{"location":"getting-started/writing-circuits/#writing-circuits","text":"circom allows programmers to define the constraints that define the arithmetic circuit. All constraints must be of the form A*B + C = 0, where A, B and C are linear combinations of signals. More details about these equations can be found here . The arithmetic circuits built using circom operate on signals. Let us define our first circuit that simply multiplies two input signals and produces an output signal. pragma circom 2.0.0; /*This circuit template checks that c is the multiplication of a and b.*/ template Multiplier2 () { // Declaration of signals. signal input a; signal input b; signal output c; // Constraints. c <== a * b; } First, the pragma instruction is used to specify the compiler version. This is to ensure that the circuit is compatible with the compiler version indicated after the pragma instruction. Otherwise, the compiler will throw a warning. Then, we use the reserved keyword template to define the shape of a new circuit, called Multiplier2 . Now, we have to define its signals . Signals can be named with an identifier, e.g., a, b, c. In this circuit, we have two input signals a, b and an output signal c . Finally, we use <== to set that the value of c is the result of multiplying the values of a and b . Equivalently, we could have also used the operator ==> , e.g., a * b ==> c . Let us notice that in each template, we first declare its signals, and after that, the associated constraints.","title":"Writing circuits"},{"location":"more-circuits/more-basic-circuits/","text":"More basic circuits Extending our multiplier to three inputs Building on top of the 2-input multiplier, we can build a 3-input multiplier. pragma circom 2.0.0; template Multiplier2(){ /*Code from the previous example.*/ } //This circuit multiplies in1, in2, and in3. template Multiplier3 () { //Declaration of signals and components. signal input in1; signal input in2; signal input in3; signal output out; component mult1 = Multiplier2(); component mult2 = Multiplier2(); //Statements. mult1.in1 <== in1; mult1.in2 <== in2; mult2.in1 <== mult1.out; mult2.in2 <== in3; out <== mult2.out; } component main = Multiplier3(); As expected, we first declare three input signals in1, in2, in3, and an output signal out and two instances of Multiplier2 . Instantiations of templates are done using the keyword component . We need an instance mult1 to multiply in1 and in2 . In order to assign the values of the input signals of mult1 we use the dot notation \".\" . Once mult1.in1 and mult1.in2 have their values set, then the value of mult1.out is computed. This value can be now used to set the input value of mult2 of the second instance of Multiplier2 to multiply in1*in2 and in3 obtaining the final result in1*in2*in3 . Finally, every execution starts from an initial main component defined as follows. component main {public [in1,in2,in3]} = Multiplier3(); Here, we indicate that the initial component for our first circom program is the circuit Multiplier3 which has three public signals: in1, in2 and in3 . In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of signals are all private and cannot be made public. Extending our multiplier to N inputs When defining a template, we can use parameters to build generic circuits. These parameters must have a known value at the moment of the instantiation of the template. Following up the previous example, we can implement an N-input multiplier, where N is a parameter. pragma circom 2.0.0; template Multiplier2(){ /*Code from the previous example.*/ } template MultiplierN (N){ //Declaration of signals and components. signal input in[N]; signal output out; component comp[N-1]; //Statements. for(var i = 0; i < N-1; i++){ comp[i] = Multiplier2(); } // ... some more code (see below) } component main = MultiplierN(4); In addition to the parameter N , two well-known concepts appear in this fragment of code: arrays and integer variables . As we have seen for a 3-input multiplier, we need 3 input signals and 2 components of Multiplier2 . Then, for an N-input multiplier, we need an N-dimensional array of input signals and an \\(N-1\\) -dimensional array of components of Multiplier2 . We also need an integer variable i to instantiate each component comp[i] . Once this is done, we have to set the signals for each component as follows: comp[0].in1 <== in[0]; comp[0].in2 <== in[1]; for(var i = 0; i < N-2; i++){ comp[i+1].in1 <== comp[i].out; comp[i+1].in2 <== in[i+2]; } out <== comp[N-2].out; } Similarly to Multiplier3 , each output signal of a component becomes one of the input signals of the next component. Finally, out is set as the output signal of the last component and its value will be in[0]*in[1]*...*in[N-1] . Finally, we define as main component a MultiplierN with N = 3 . component main {public [in]} = MultiplierN(3); pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals. signal input in1; signal input in2; signal output out; //Statements. out <== in1 * in2; } template Multiplier3 () { //Declaration of signals. signal input in1; signal input in2; signal input in3; signal output out; component mult1 = Multiplier2(); component mult2 = Multiplier2(); //Statements. mult1.in1 <== in1; mult1.in2 <== in2; mult2.in1 <== mult1.out; mult2.in2 <== in3; out <== mult2.out; } template MultiplierN (N){ //Declaration of signals. signal input in[N]; signal output out; component comp[N-1]; //Statements. for(var i = 0; i < N-1; i++){ comp[i] = Multiplier2(); } comp[0].in1 <== in[0]; comp[0].in2 <== in[1]; for(var i = 0; i < N-2; i++){ comp[i+1].in1 <== comp[i].out; comp[i+1].in2 <== in[i+2]; } out <== comp[N-2].out; } component main {public [in]} = MultiplierN(3); Writing a circuit for binary checks Let us build a circuit that checks if the input signal is binary. In case it is, the circuit returns an output signal with the same value than in . pragma circom 2.0.0; template binaryCheck () { // Declaration of signals. signal input in; signal output out; // Statements. in * (in-1) === 0; out <== in; } component main = binaryCheck(); After declaring the signals of the circuit, we use the operator === to introduce the constraint in * (in -1) = 0 . The solutions of this constraint are in = 0 and in = 1 . This means that the constraint has solution if and only if the input signal is binary. The instruction out <== in not only assigns the value of signal in to signal out , but it also adds the constraint out = in to the set of constraints that define the circuit. Then, when both constraints have solution, it is guaranteed that the output signal is binary. Sometimes, we only want to assign the value of a signal but not adding the corresponding constraint. In this case, we will use the operator <-- and --> . The differences between <--/--> and <==/==> are described here . Writing a logic gate AND with two inputs We are going to use the circuits Multiplier2 and binaryCheck to build a 2-gate logic AND. pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out; //Statements. out <== in1 * in2; } template binaryCheck () { //Declaration of signals. signal input in; signal output out; //Statements. in * (in-1) === 0; out <== in; } template And2(){ //Declaration of signals and components. signal input in1; signal input in2; signal output out; component mult = Multiplier2(); component binCheck[2]; //Statements. binCheck[0] = binaryCheck(); binCheck[0].in <== in1; binCheck[1] = binaryCheck(); binCheck[1].in <== in2; mult.in1 <== binCheck[0].out; mult.in2 <== binCheck[1].out; out <== mult.out; } component main = And2(); Simplifying, the 2-gate AND circuit can be defined by the next constraints: in1 * (in1 - 1) = 0 , in2 * (in2 - 1) = 0 , out = in1 * in2 These constraints are satisfiable if and only if in1, in2 are binary signals. Consequently, out will also be binary. Extending our AND logic gate to N inputs Finally, let us build an N-gate logic AND using circuit Multiplier2 and binaryCheck . pragma circom 2.0.0; template binaryCheck () { /*Code from previous example*/ } template Multiplier2 () { /*Code from previous example*/ } template AndN (N){ //Declaration of signals and components. signal input in[N]; signal output out; component mult[N-1]; component binCheck[N]; //Statements. for(var i = 0; i < N; i++){ binCheck[i] = binaryCheck(); binCheck[i].in <== in[i]; } for(var i = 0; i < N-1; i++){ mult[i] = Multiplier2(); } mult[0].in1 <== binCheck[0].out; mult[0].in2 <== binCheck[1].out; for(var i = 0; i < N-2; i++){ mult[i+1].in1 <== mult[i].out; mult[i+1].in2 <== binCheck[i+2].out; } out <== mult[N-2].out; } component main = AndN(4); This program is very similar to MultiplierN , but every signal involved in it is binary. It is important to highlight that we cannot use a (2N-1)-dimensional array to instantiate all the components since, every component of an array must be an instance of the same template with (optionally) different parameters.","title":"Basic circuits"},{"location":"more-circuits/more-basic-circuits/#more-basic-circuits","text":"","title":"More basic circuits"},{"location":"more-circuits/more-basic-circuits/#extending-our-multiplier-to-three-inputs","text":"Building on top of the 2-input multiplier, we can build a 3-input multiplier. pragma circom 2.0.0; template Multiplier2(){ /*Code from the previous example.*/ } //This circuit multiplies in1, in2, and in3. template Multiplier3 () { //Declaration of signals and components. signal input in1; signal input in2; signal input in3; signal output out; component mult1 = Multiplier2(); component mult2 = Multiplier2(); //Statements. mult1.in1 <== in1; mult1.in2 <== in2; mult2.in1 <== mult1.out; mult2.in2 <== in3; out <== mult2.out; } component main = Multiplier3(); As expected, we first declare three input signals in1, in2, in3, and an output signal out and two instances of Multiplier2 . Instantiations of templates are done using the keyword component . We need an instance mult1 to multiply in1 and in2 . In order to assign the values of the input signals of mult1 we use the dot notation \".\" . Once mult1.in1 and mult1.in2 have their values set, then the value of mult1.out is computed. This value can be now used to set the input value of mult2 of the second instance of Multiplier2 to multiply in1*in2 and in3 obtaining the final result in1*in2*in3 . Finally, every execution starts from an initial main component defined as follows. component main {public [in1,in2,in3]} = Multiplier3(); Here, we indicate that the initial component for our first circom program is the circuit Multiplier3 which has three public signals: in1, in2 and in3 . In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of signals are all private and cannot be made public.","title":"Extending our multiplier to three inputs"},{"location":"more-circuits/more-basic-circuits/#extending-our-multiplier-to-n-inputs","text":"When defining a template, we can use parameters to build generic circuits. These parameters must have a known value at the moment of the instantiation of the template. Following up the previous example, we can implement an N-input multiplier, where N is a parameter. pragma circom 2.0.0; template Multiplier2(){ /*Code from the previous example.*/ } template MultiplierN (N){ //Declaration of signals and components. signal input in[N]; signal output out; component comp[N-1]; //Statements. for(var i = 0; i < N-1; i++){ comp[i] = Multiplier2(); } // ... some more code (see below) } component main = MultiplierN(4); In addition to the parameter N , two well-known concepts appear in this fragment of code: arrays and integer variables . As we have seen for a 3-input multiplier, we need 3 input signals and 2 components of Multiplier2 . Then, for an N-input multiplier, we need an N-dimensional array of input signals and an \\(N-1\\) -dimensional array of components of Multiplier2 . We also need an integer variable i to instantiate each component comp[i] . Once this is done, we have to set the signals for each component as follows: comp[0].in1 <== in[0]; comp[0].in2 <== in[1]; for(var i = 0; i < N-2; i++){ comp[i+1].in1 <== comp[i].out; comp[i+1].in2 <== in[i+2]; } out <== comp[N-2].out; } Similarly to Multiplier3 , each output signal of a component becomes one of the input signals of the next component. Finally, out is set as the output signal of the last component and its value will be in[0]*in[1]*...*in[N-1] . Finally, we define as main component a MultiplierN with N = 3 . component main {public [in]} = MultiplierN(3); pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals. signal input in1; signal input in2; signal output out; //Statements. out <== in1 * in2; } template Multiplier3 () { //Declaration of signals. signal input in1; signal input in2; signal input in3; signal output out; component mult1 = Multiplier2(); component mult2 = Multiplier2(); //Statements. mult1.in1 <== in1; mult1.in2 <== in2; mult2.in1 <== mult1.out; mult2.in2 <== in3; out <== mult2.out; } template MultiplierN (N){ //Declaration of signals. signal input in[N]; signal output out; component comp[N-1]; //Statements. for(var i = 0; i < N-1; i++){ comp[i] = Multiplier2(); } comp[0].in1 <== in[0]; comp[0].in2 <== in[1]; for(var i = 0; i < N-2; i++){ comp[i+1].in1 <== comp[i].out; comp[i+1].in2 <== in[i+2]; } out <== comp[N-2].out; } component main {public [in]} = MultiplierN(3);","title":"Extending our multiplier to N inputs"},{"location":"more-circuits/more-basic-circuits/#writing-a-circuit-for-binary-checks","text":"Let us build a circuit that checks if the input signal is binary. In case it is, the circuit returns an output signal with the same value than in . pragma circom 2.0.0; template binaryCheck () { // Declaration of signals. signal input in; signal output out; // Statements. in * (in-1) === 0; out <== in; } component main = binaryCheck(); After declaring the signals of the circuit, we use the operator === to introduce the constraint in * (in -1) = 0 . The solutions of this constraint are in = 0 and in = 1 . This means that the constraint has solution if and only if the input signal is binary. The instruction out <== in not only assigns the value of signal in to signal out , but it also adds the constraint out = in to the set of constraints that define the circuit. Then, when both constraints have solution, it is guaranteed that the output signal is binary. Sometimes, we only want to assign the value of a signal but not adding the corresponding constraint. In this case, we will use the operator <-- and --> . The differences between <--/--> and <==/==> are described here .","title":"Writing a circuit for binary checks"},{"location":"more-circuits/more-basic-circuits/#writing-a-logic-gate-and-with-two-inputs","text":"We are going to use the circuits Multiplier2 and binaryCheck to build a 2-gate logic AND. pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out; //Statements. out <== in1 * in2; } template binaryCheck () { //Declaration of signals. signal input in; signal output out; //Statements. in * (in-1) === 0; out <== in; } template And2(){ //Declaration of signals and components. signal input in1; signal input in2; signal output out; component mult = Multiplier2(); component binCheck[2]; //Statements. binCheck[0] = binaryCheck(); binCheck[0].in <== in1; binCheck[1] = binaryCheck(); binCheck[1].in <== in2; mult.in1 <== binCheck[0].out; mult.in2 <== binCheck[1].out; out <== mult.out; } component main = And2(); Simplifying, the 2-gate AND circuit can be defined by the next constraints: in1 * (in1 - 1) = 0 , in2 * (in2 - 1) = 0 , out = in1 * in2 These constraints are satisfiable if and only if in1, in2 are binary signals. Consequently, out will also be binary.","title":"Writing a logic gate AND with two inputs"},{"location":"more-circuits/more-basic-circuits/#extending-our-and-logic-gate-to-n-inputs","text":"Finally, let us build an N-gate logic AND using circuit Multiplier2 and binaryCheck . pragma circom 2.0.0; template binaryCheck () { /*Code from previous example*/ } template Multiplier2 () { /*Code from previous example*/ } template AndN (N){ //Declaration of signals and components. signal input in[N]; signal output out; component mult[N-1]; component binCheck[N]; //Statements. for(var i = 0; i < N; i++){ binCheck[i] = binaryCheck(); binCheck[i].in <== in[i]; } for(var i = 0; i < N-1; i++){ mult[i] = Multiplier2(); } mult[0].in1 <== binCheck[0].out; mult[0].in2 <== binCheck[1].out; for(var i = 0; i < N-2; i++){ mult[i+1].in1 <== mult[i].out; mult[i+1].in2 <== binCheck[i+2].out; } out <== mult[N-2].out; } component main = AndN(4); This program is very similar to MultiplierN , but every signal involved in it is binary. It is important to highlight that we cannot use a (2N-1)-dimensional array to instantiate all the components since, every component of an array must be an instance of the same template with (optionally) different parameters.","title":"Extending our AND logic gate to N inputs"}]}